<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Humanity Network</title>
  <meta name="description" content="A cooperative chat platform with cryptographic identity. No accounts, no tracking. Just people talking freely.">
  <meta property="og:type" content="website">
  <meta property="og:title" content="Humanity Network — Chat">
  <meta property="og:description" content="A cooperative chat platform with cryptographic identity. No accounts, no tracking, no surveillance.">
  <meta property="og:url" content="https://united-humanity.us/chat">
  <meta property="og:image" content="https://united-humanity.us/favicon.png">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Humanity Network — Chat">
  <meta name="twitter:description" content="Cooperative chat with Ed25519 identity. No accounts. No tracking.">
  <meta name="twitter:image" content="https://united-humanity.us/favicon.png">
  <meta name="theme-color" content="#FF8811">
  <link rel="manifest" href="/shared/manifest.json">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Humanity">
  <link rel="apple-touch-icon" href="/shared/icons/icon-192.png">
  <link rel="icon" type="image/svg+xml" href="/favicon.svg">
  <link rel="icon" type="image/png" href="/favicon.png">
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="stylesheet" href="/shared/theme.css">
  <style>
    :root {
      --accent: #e07020;
      --accent-hover: #ff8c40;
      --accent-dim: rgba(224,112,32,0.15);
    }

    body {
      height: 100vh;
      display: flex;
      flex-direction: column;
      padding-bottom: 28px;
    }

    /* ── Header ── */
    header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 0.6rem 1rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-height: 48px;
    }

    .header-left { display: flex; align-items: center; gap: 0.75rem; }

    header h1 {
      font-size: 1rem;
      color: var(--accent);
      font-weight: 600;
    }

    #stats {
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    #status {
      font-size: 0.75rem;
      color: var(--text-muted);
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    #status .dot {
      width: 8px; height: 8px; border-radius: 50%;
      background: var(--danger);
      display: inline-block;
    }

    #status.connected .dot { background: var(--success); }
    #status.reconnecting .dot { background: var(--warning); animation: pulse 1s infinite; }

    @keyframes pulse { 0%,100% { opacity:1; } 50% { opacity:0.3; } }

    /* ── Layout ── */
    .main {
      flex: 1;
      display: flex;
      overflow: hidden;
      min-height: 0;
    }

    /* ── Sidebar ── */
    #sidebar {
      width: 200px;
      background: var(--bg-secondary);
      border-right: 1px solid var(--border);
      padding: 0.75rem;
      overflow-y: auto;
      flex-shrink: 0;
    }

    #sidebar h3 {
      font-size: 0.65rem;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      letter-spacing: 0.08em;
    }

    .channel-item {
      font-size: 0.82rem;
      padding: 0.3rem 0.5rem;
      color: var(--text-muted);
      border-radius: 4px;
      cursor: pointer;
    }
    .channel-item:hover { background: var(--bg-hover); color: var(--text); }
    .channel-item.active {
      background: var(--accent-dim);
      color: var(--accent);
      font-weight: 600;
    }
    .channel-item::before { content: '# '; opacity: 0.6; }

    #channel-header {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 0.4rem 1rem;
      font-size: 0.78rem;
      display: none;
    }
    #channel-header .ch-name {
      font-weight: 600;
      color: var(--text);
    }
    #channel-header .ch-desc {
      color: var(--text-muted);
      margin-left: 0.5rem;
    }

    .peer {
      font-size: 0.8rem;
      padding: 0.3rem 0.4rem;
      color: var(--text);
      border-radius: 4px;
    }

    .peer:hover { background: var(--bg-hover); }

    .peer .key {
      font-size: 0.6rem;
      color: var(--text-muted);
      font-family: monospace;
    }

    .peer.is-you { color: var(--accent); }

    /* ── Chat ── */
    #chat-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    #messages {
      flex: 1;
      overflow-y: auto;
      padding: 0.75rem 1rem;
      scroll-behavior: smooth;
    }

    .message {
      margin-bottom: 0.35rem;
      line-height: 1.4;
      padding: 0.45rem 0.6rem;
      background: rgba(255,255,255,0.02);
      border-radius: 8px;
    }

    .message .meta {
      display: flex;
      align-items: baseline;
      gap: 0.5rem;
    }

    .message .author {
      font-weight: 600;
      color: var(--accent);
      font-size: 0.85rem;
    }

    .message .author.bot { color: #7aa4d8; }
    .message .author.you { color: var(--success); }

    .identicon {
      width: 18px;
      height: 18px;
      border-radius: 3px;
      vertical-align: middle;
      margin-right: 0.1rem;
    }

    .reactions {
      display: flex;
      flex-wrap: wrap;
      gap: 0.2rem;
      margin-top: 0.15rem;
      padding-left: 1.6rem;
    }
    .reactions:empty { display: none; }
    .reaction-badge {
      display: inline-flex;
      align-items: center;
      gap: 0.2rem;
      background: var(--bg-hover);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 0.05rem 0.4rem;
      font-size: 0.75rem;
      cursor: pointer;
      user-select: none;
    }
    .reaction-badge:hover { border-color: var(--accent); }
    .reaction-badge.mine { border-color: var(--accent); background: var(--accent-dim); }
    .reaction-badge .count { font-size: 0.65rem; color: var(--text-muted); }

    .sig-badge {
      font-size: 0.65rem;
      color: var(--success);
      background: rgba(68,170,153,0.15);
      padding: 0 0.3rem;
      border-radius: 3px;
      font-weight: 600;
    }

    .message .time {
      font-size: 0.65rem;
      color: var(--text-muted);
    }

    .message .body {
      font-size: 0.9rem;
      margin-top: 0.3rem;
      margin-left: 1.6rem;
      padding: 0.35rem 0.55rem;
      background: rgba(255,255,255,0.025);
      border-radius: 6px;
      word-wrap: break-word;
      white-space: pre-wrap;
    }

    .message.system {
      color: var(--text-muted);
      font-style: italic;
      font-size: 0.75rem;
      padding: 0.15rem 0;
      margin-bottom: 0.25rem;
      background: none;
      border-radius: 0;
    }

    /* Ephemeral notices — color-coded, auto-dismiss */
    .notice {
      padding: 0.4rem 0.75rem;
      border-radius: 6px;
      font-size: 0.8rem;
      margin-bottom: 0.3rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      animation: noticeFadeIn 0.2s ease;
    }
    .notice .notice-text { flex: 1; }
    .notice .notice-timer {
      font-size: 0.65rem;
      opacity: 0.7;
      margin-left: 0.5rem;
      white-space: nowrap;
    }
    .notice.notice-red    { background: rgba(220,50,50,0.12); border-left: 3px solid #dc3232; color: #ff6b6b; }
    .notice.notice-yellow { background: rgba(220,180,50,0.10); border-left: 3px solid #dcb432; color: #e0c860; }
    .notice.notice-green  { background: rgba(50,180,80,0.10); border-left: 3px solid #32b450; color: #60d080; }
    .notice.notice-blue   { background: rgba(50,120,220,0.10); border-left: 3px solid #3278dc; color: #60a0e0; }
    .notice.notice-cyan   { background: rgba(50,200,200,0.10); border-left: 3px solid #32c8c8; color: #60e0e0; }
    .notice.notice-magenta { background: rgba(180,50,200,0.10); border-left: 3px solid #b432c8; color: #d060e0; }
    @keyframes noticeFadeIn { from { opacity: 0; transform: translateY(-4px); } to { opacity: 1; transform: none; } }
    .notice.fading { transition: opacity 0.5s ease; opacity: 0; }

    .date-separator {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.7rem;
      padding: 0.75rem 0 0.5rem;
      position: relative;
    }

    .date-separator::before,
    .date-separator::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 30%;
      height: 1px;
      background: var(--border);
    }

    .date-separator::before { left: 5%; }
    .date-separator::after { right: 5%; }

    #history-notice {
      text-align: center;
      color: var(--text-muted);
      font-size: 0.7rem;
      padding: 0.5rem;
      font-style: italic;
    }

    /* ── Input ── */
    #input-area {
      border-top: 1px solid var(--border);
      padding: 0.6rem 0.75rem;
      display: flex;
      gap: 0.5rem;
      background: var(--bg-secondary);
    }

    #msg-input {
      flex: 1;
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.55rem 0.75rem;
      border-radius: 6px;
      font-size: 0.9rem;
      outline: none;
      font-family: inherit;
      resize: none;
      min-height: 38px;
      max-height: 150px;
      overflow-y: auto;
      line-height: 1.4;
    }

    #msg-input:focus { border-color: var(--accent); }

    #send-btn {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.55rem 1rem;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      font-weight: 600;
      white-space: nowrap;
    }

    #send-btn:hover { background: var(--accent-hover); }
    #send-btn:disabled { opacity: 0.4; cursor: not-allowed; }

    /* ── Command Palette ── */
    #cmd-palette-btn {
      width: 38px;
      height: 38px;
      min-width: 38px;
      border-radius: 50%;
      border: 1px solid var(--border);
      background: var(--bg-secondary);
      color: var(--text-muted);
      font-size: 1.2rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.15s, color 0.15s, border-color 0.15s;
      flex-shrink: 0;
    }
    #cmd-palette-btn:hover { background: var(--accent); color: #fff; border-color: var(--accent); }

    #cmd-palette-overlay {
      display: none;
      position: fixed;
      inset: 0;
      z-index: 999;
    }
    #cmd-palette-overlay.open { display: block; }

    #cmd-palette {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 340px;
      max-height: 420px;
      overflow-y: auto;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 -4px 24px rgba(0,0,0,0.5);
      padding: 0.5rem 0;
      opacity: 0;
      transform: translateY(8px);
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 1000;
    }
    #cmd-palette-overlay.open #cmd-palette {
      opacity: 1;
      transform: translateY(0);
    }

    #cmd-palette .cp-category {
      padding: 0.5rem 0.8rem 0.2rem;
      font-size: 0.7rem;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--accent);
    }

    #cmd-palette .cp-item {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      padding: 0.45rem 0.8rem;
      cursor: pointer;
      font-size: 0.82rem;
      color: var(--text);
      transition: background 0.1s;
    }
    #cmd-palette .cp-item:hover { background: var(--bg-hover); }
    #cmd-palette .cp-item .cp-icon { font-size: 1rem; flex-shrink: 0; width: 1.4rem; text-align: center; }
    #cmd-palette .cp-item .cp-label { font-weight: 500; }
    #cmd-palette .cp-item .cp-desc { font-size: 0.72rem; color: var(--text-muted); margin-left: auto; white-space: nowrap; }

    @media (max-width: 600px) {
      #cmd-palette { width: calc(100vw - 1rem); left: 0.5rem; right: 0.5rem; max-height: 55vh; }
    }

    /* ── Login ── */
    #login-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1;
      min-height: 0;
      gap: 1rem;
      padding: 1rem;
    }

    #login-screen h1 {
      color: var(--accent);
      font-size: 1.8rem;
    }

    #login-screen p {
      color: var(--text-muted);
      max-width: 420px;
      text-align: center;
      line-height: 1.6;
      font-size: 0.9rem;
    }

    #login-screen input {
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.6rem 0.75rem;
      border-radius: 6px;
      font-size: 1rem;
      width: 340px;
      max-width: 90vw;
      text-align: center;
      outline: none;
    }

    #login-screen input:focus { border-color: var(--accent); }

    #login-screen button {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.6rem 2rem;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      font-weight: 600;
    }

    #login-screen button:hover { background: var(--accent-hover); }

    .subtitle {
      font-size: 0.72rem !important;
      color: var(--text-muted) !important;
      margin-top: 0.5rem;
    }

    #chat-screen { display: none; flex: 1; min-height: 0; flex-direction: column; }

    /* ── Message hover actions ── */
    .message { position: relative; cursor: pointer; border-radius: 4px; padding: 0.3rem 0.4rem; }
    .message:hover { background: var(--bg-hover); }
    .message .msg-actions {
      display: none;
      position: absolute;
      right: 0.5rem;
      top: 0.2rem;
      gap: 0.3rem;
    }
    .message:hover .msg-actions { display: flex; }
    .msg-actions button {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 0.65rem;
      padding: 0.15rem 0.4rem;
      border-radius: 3px;
      cursor: pointer;
    }
    .msg-actions button:hover { color: var(--text); border-color: var(--accent); }

    /* ── Quote/reply styling ── */
    .body .quote-block {
      border-left: 3px solid var(--accent);
      padding: 0.15rem 0 0.15rem 0.5rem;
      margin: 0 0 0.2rem 0;
      color: var(--text-muted);
      font-size: 0.82em;
      line-height: 1.3;
      cursor: pointer;
    }
    .body .quote-block:hover { background: var(--bg-hover); }
    .body .quote-block .quote-expand {
      color: var(--accent);
      font-size: 0.75em;
      display: inline;
      margin-left: 0.3rem;
    }
    .body .quote-block .quote-full { display: none; }
    .body .quote-block.expanded .quote-full { display: block; }
    .body .quote-block.expanded .quote-preview { display: none; }

    /* ── Image messages ── */
    .body .img-placeholder {
      display: inline-flex;
      align-items: center;
      gap: 0.4rem;
      background: var(--bg-hover);
      border: 1px solid var(--border);
      border-radius: 4px;
      padding: 0.3rem 0.6rem;
      cursor: pointer;
      font-size: 0.8rem;
      color: var(--accent);
      margin: 0.2rem 0;
    }
    .body .img-placeholder:hover { border-color: var(--accent); }
    .body .img-loaded {
      max-width: 400px;
      max-height: 300px;
      border-radius: 4px;
      margin: 0.2rem 0;
      cursor: pointer;
    }
    .body .img-loaded:hover { opacity: 0.9; }

    /* ── Upload indicator ── */
    #upload-indicator {
      font-size: 0.7rem;
      color: var(--accent);
      padding: 0.2rem 0.75rem;
      display: none;
    }

    /* ── Character counter ── */
    #char-counter {
      font-size: 0.65rem;
      color: var(--text-muted);
      text-align: right;
      padding: 0 0.75rem;
      display: none;
    }
    #char-counter.warn { color: var(--warning); }
    #char-counter.over { color: var(--danger); font-weight: 600; }

    /* ── Reply bar ── */
    #reply-bar {
      background: var(--bg-secondary);
      border-top: 1px solid var(--border);
      border-left: 3px solid var(--accent);
      padding: 0.4rem 0.75rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      cursor: pointer;
    }
    #reply-preview {
      flex: 1;
      font-size: 0.78rem;
      color: var(--text-muted);
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
    }
    #reply-preview .reply-author {
      color: var(--accent);
      font-weight: 600;
    }
    #reply-cancel {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 0.9rem;
      cursor: pointer;
      padding: 0.1rem 0.3rem;
    }
    #reply-cancel:hover { color: var(--text); }

    /* ── Typing indicator ── */
    #typing-indicator {
      font-size: 0.72rem;
      color: var(--text-muted);
      font-style: italic;
      padding: 0.2rem 0.75rem;
      min-height: 1.2rem;
    }

    /* ── Inline code & bold/italic from markdown ── */
    .body code {
      background: var(--bg-hover);
      padding: 0.1rem 0.3rem;
      border-radius: 3px;
      font-size: 0.85em;
      font-family: monospace;
    }

    /* ── New messages divider ── */
    .new-messages-divider {
      text-align: center;
      color: var(--danger);
      font-size: 0.7rem;
      padding: 0.5rem 0;
      position: relative;
    }
    .new-messages-divider::before,
    .new-messages-divider::after {
      content: '';
      position: absolute;
      top: 50%;
      width: 30%;
      height: 1px;
      background: var(--danger);
    }
    .new-messages-divider::before { left: 5%; }
    .new-messages-divider::after { right: 5%; }

    /* ── Hamburger menu for mobile ── */
    #hamburger {
      display: none;
      background: none;
      border: none;
      color: var(--text);
      font-size: 1.3rem;
      cursor: pointer;
      padding: 0.2rem;
    }

    /* ── Right Sidebar ── */
    #right-sidebar {
      width: 200px;
      background: var(--bg-secondary);
      border-left: 1px solid var(--border);
      padding: 0.75rem;
      overflow-y: auto;
      flex-shrink: 0;
    }

    #right-sidebar h3 {
      font-size: 0.65rem;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 0.5rem;
      letter-spacing: 0.08em;
    }

    /* ── Help Button ── */
    #help-btn {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text-muted);
      font-size: 0.85rem;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }
    #help-btn:hover { color: var(--accent); border-color: var(--accent); }

    /* ── Help Modal ── */
    #help-modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      z-index: 100;
      align-items: center;
      justify-content: center;
    }
    #help-modal-overlay.open { display: flex; }

    #help-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      max-width: 520px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      padding: 1.2rem;
      position: relative;
    }

    #help-modal h2 {
      font-size: 1rem;
      color: var(--accent);
      margin-bottom: 0.75rem;
    }

    #help-modal h4 {
      font-size: 0.8rem;
      color: var(--text);
      margin: 0.75rem 0 0.3rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #help-modal .cmd {
      font-size: 0.8rem;
      padding: 0.2rem 0;
      color: var(--text-muted);
      line-height: 1.5;
    }

    #help-modal .cmd code {
      background: var(--bg-hover);
      padding: 0.1rem 0.35rem;
      border-radius: 3px;
      color: var(--accent);
      font-family: monospace;
      font-size: 0.78rem;
    }

    #help-close {
      position: absolute;
      top: 0.6rem;
      right: 0.8rem;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.1rem;
      cursor: pointer;
    }
    #help-close:hover { color: var(--text); }

    /* ── Context Menu ── */
    #user-context-menu {
      display: none;
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      min-width: 150px;
      z-index: 200;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      padding: 0.3rem 0;
    }
    #user-context-menu.open { display: block; }
    .ctx-item {
      padding: 0.4rem 0.75rem;
      font-size: 0.8rem;
      color: var(--text);
      cursor: pointer;
      white-space: nowrap;
    }
    .ctx-item:hover { background: var(--bg-hover); color: var(--accent); }
    .ctx-sep {
      height: 1px;
      background: var(--border);
      margin: 0.2rem 0;
    }

    /* ── Role Badges ── */
    .role-badge {
      font-size: 0.7rem;
      margin-left: 0.2rem;
      vertical-align: middle;
    }

    /* ── People toggle button (mobile) ── */
    #people-toggle {
      display: none;
      background: none;
      border: none;
      color: var(--text);
      font-size: 1.2rem;
      cursor: pointer;
      padding: 0.2rem;
    }

    /* ── Sidebar overlay backdrop (mobile) ── */
    #sidebar-overlay {
      display: none;
      position: fixed;
      top: 48px; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 9;
    }
    #sidebar-overlay.open { display: block; }

    /* ── Unread indicator ── */
    .channel-item .unread-dot {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      margin-left: 0.4rem;
      vertical-align: middle;
      animation: pulse 1.5s ease-in-out 3;
    }
    .channel-item.has-unread {
      color: var(--text);
      font-weight: 600;
    }

    /* ── Mobile ── */
    @media (max-width: 640px) {
      #sidebar {
        display: none;
        position: fixed;
        left: 0; top: 48px; bottom: 0;
        z-index: 10;
        width: 260px;
        max-width: 80vw;
        box-shadow: 4px 0 16px rgba(0,0,0,0.4);
      }
      #sidebar.open { display: block; }
      #right-sidebar {
        display: none;
        position: fixed;
        right: 0; top: 48px; bottom: 0;
        z-index: 10;
        width: 260px;
        max-width: 80vw;
        box-shadow: -4px 0 16px rgba(0,0,0,0.4);
      }
      #right-sidebar.open { display: block; }
      #hamburger { display: block; }
      #people-toggle { display: block; }
      header h1 { font-size: 0.9rem; }

      /* Prevent iOS zoom on input focus */
      #msg-input { font-size: 16px; }

      /* Comfortable input area on mobile */
      #input-area {
        padding: 0.5rem;
        gap: 0.4rem;
      }
      #send-btn {
        padding: 0.6rem 0.9rem;
        font-size: 0.9rem;
        min-width: 52px;
        min-height: 44px;
      }
      #help-btn {
        min-width: 36px;
        min-height: 36px;
        font-size: 0.9rem;
      }
      #msg-input {
        padding: 0.6rem 0.7rem;
        min-height: 44px;
      }

      /* Message bubbles: more breathing room */
      .message {
        padding: 0.35rem 0.4rem;
        margin-bottom: 0.1rem;
      }
      .message .body {
        font-size: 0.92rem;
        line-height: 1.45;
      }
      .message .time {
        font-size: 0.6rem;
      }

      /* Channel items: larger tap targets */
      .channel-item {
        padding: 0.45rem 0.6rem;
        font-size: 0.88rem;
        min-height: 36px;
        display: flex;
        align-items: center;
      }

      /* Peer items: larger tap targets */
      .peer {
        padding: 0.45rem 0.5rem;
        font-size: 0.85rem;
        min-height: 36px;
      }

      /* Profile modals: full-width on mobile */
      .profile-modal {
        width: 95%;
        max-width: none;
        max-height: 90vh;
        border-radius: 8px 8px 0 0;
      }

      /* Help modal: full-width, scrollable */
      #help-modal {
        width: 95%;
        max-width: none;
        max-height: 85vh;
        border-radius: 8px 8px 0 0;
      }

      /* Image placeholders: easier to tap */
      .body .img-placeholder {
        padding: 0.5rem 0.8rem;
        font-size: 0.85rem;
        min-height: 40px;
      }
      .body .img-loaded {
        max-width: calc(100vw - 2rem);
        max-height: 250px;
      }

      /* Reaction badges: bigger on mobile */
      .reaction-badge {
        padding: 0.15rem 0.5rem;
        font-size: 0.82rem;
        min-height: 30px;
      }
      .reaction-badge .count {
        font-size: 0.72rem;
      }

      /* Channel header: compact */
      #channel-header {
        padding: 0.35rem 0.6rem;
        font-size: 0.75rem;
      }

      /* Hide message hover actions on mobile (use long-press or context menu) */
      .message .msg-actions {
        display: none !important;
      }
      /* Instead, show actions on tap (added via JS) */
      .message.mobile-selected .msg-actions {
        display: flex !important;
        position: static;
        margin-top: 0.25rem;
        gap: 0.4rem;
      }
      .message.mobile-selected .msg-actions button {
        padding: 0.3rem 0.6rem;
        font-size: 0.75rem;
        min-height: 32px;
      }

      /* Login page adjustments */
      #login-screen h1 { font-size: 1.5rem; }
      #login-screen p { font-size: 0.85rem; }
      #login-screen input { width: 100%; max-width: 340px; }
      #login-screen button { width: 100%; max-width: 340px; }

      /* Sidebar tabs: slightly bigger on mobile */
      .sidebar-tab {
        font-size: 0.7rem;
        height: 32px;
        min-height: 32px;
      }
      .server-group-header {
        padding: 0.4rem 0.5rem;
        min-height: 36px;
      }
    }

    /* ── Profile Modals ── */
    .profile-modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.6);
      z-index: 150;
      align-items: center;
      justify-content: center;
    }
    .profile-modal-overlay.open { display: flex; }

    .profile-modal {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      max-width: 480px;
      width: 90%;
      max-height: 85vh;
      overflow-y: auto;
      padding: 1.2rem;
      position: relative;
    }

    .profile-modal h2 {
      font-size: 1rem;
      color: var(--accent);
      margin-bottom: 0.75rem;
    }

    .profile-modal label {
      display: block;
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-bottom: 0.2rem;
      margin-top: 0.6rem;
    }

    .profile-modal textarea,
    .profile-modal input[type="text"] {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.45rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-family: inherit;
      outline: none;
      resize: vertical;
    }

    .profile-modal textarea:focus,
    .profile-modal input[type="text"]:focus { border-color: var(--accent); }

    .profile-modal .bio-counter {
      font-size: 0.65rem;
      color: var(--text-muted);
      text-align: right;
      margin-top: 0.1rem;
    }
    .profile-modal .bio-counter.warn { color: var(--warning); }
    .profile-modal .bio-counter.over { color: var(--danger); font-weight: 600; }

    .profile-modal .btn-row {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
      justify-content: flex-end;
    }

    .profile-modal .btn-save {
      background: var(--accent);
      color: #fff;
      border: none;
      padding: 0.45rem 1.2rem;
      border-radius: 5px;
      font-size: 0.85rem;
      cursor: pointer;
      font-weight: 600;
    }
    .profile-modal .btn-save:hover { background: var(--accent-hover); }

    .profile-modal .btn-cancel {
      background: var(--bg-input);
      color: var(--text-muted);
      border: 1px solid var(--border);
      padding: 0.45rem 1.2rem;
      border-radius: 5px;
      font-size: 0.85rem;
      cursor: pointer;
    }
    .profile-modal .btn-cancel:hover { color: var(--text); border-color: var(--text-muted); }

    .profile-modal .close-btn {
      position: absolute;
      top: 0.6rem;
      right: 0.8rem;
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1.1rem;
      cursor: pointer;
    }
    .profile-modal .close-btn:hover { color: var(--text); }

    /* ── View Profile Card ── */
    .profile-card-header {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }
    .profile-card-header .identicon-large {
      width: 64px;
      height: 64px;
      border-radius: 6px;
    }
    .profile-card-header .profile-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text);
    }
    .profile-card-bio {
      font-size: 0.85rem;
      color: var(--text);
      line-height: 1.5;
      margin-bottom: 0.75rem;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .profile-card-socials {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
      margin-bottom: 0.75rem;
    }
    .profile-card-socials a {
      color: var(--accent);
      text-decoration: none;
      font-size: 0.8rem;
    }
    .profile-card-socials a:hover { text-decoration: underline; }
    .profile-card-socials .social-item {
      font-size: 0.8rem;
      color: var(--text-muted);
    }
    .profile-card-socials .social-label {
      color: var(--text-muted);
      min-width: 70px;
      display: inline-block;
    }
    .profile-card-key {
      font-size: 0.65rem;
      color: var(--text-muted);
      font-family: monospace;
      cursor: pointer;
      word-break: break-all;
    }
    .profile-card-key:hover { color: var(--accent); }
    .profile-card-empty {
      font-size: 0.82rem;
      color: var(--text-muted);
      font-style: italic;
      margin: 0.75rem 0;
    }

    /* ── Edited marker ── */
    .edited-marker {
      font-size: 0.65rem;
      color: var(--text-muted);
      font-style: italic;
      margin-left: 0.3rem;
    }

    /* ── Edit mode (inline editing) ── */
    .edit-area {
      display: flex;
      flex-direction: column;
      gap: 0.3rem;
      margin-top: 0.2rem;
    }
    .edit-area textarea {
      background: var(--bg-input);
      border: 1px solid var(--accent);
      color: var(--text);
      padding: 0.4rem 0.6rem;
      border-radius: 4px;
      font-size: 0.85rem;
      font-family: inherit;
      resize: vertical;
      min-height: 36px;
      outline: none;
    }
    .edit-area .edit-buttons {
      display: flex;
      gap: 0.3rem;
      justify-content: flex-end;
    }
    .edit-area .edit-buttons button {
      font-size: 0.72rem;
      padding: 0.2rem 0.6rem;
      border-radius: 4px;
      cursor: pointer;
      border: 1px solid var(--border);
    }
    .edit-area .edit-save {
      background: var(--accent);
      color: #fff;
      border-color: var(--accent);
    }
    .edit-area .edit-save:hover { background: var(--accent-hover); }
    .edit-area .edit-cancel {
      background: var(--bg-input);
      color: var(--text-muted);
    }
    .edit-area .edit-cancel:hover { color: var(--text); }

    /* ── Pin Bar ── */
    #pin-bar {
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      padding: 0.35rem 0.75rem;
      font-size: 0.78rem;
      cursor: pointer;
      display: none;
      user-select: none;
    }
    #pin-bar:hover { background: var(--bg-hover); }
    #pin-bar .pin-summary {
      color: var(--text-muted);
    }
    #pin-bar .pin-summary .pin-icon { color: var(--accent); }

    #pin-list {
      display: none;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      max-height: 300px;
      overflow-y: auto;
      padding: 0.5rem 0.75rem;
    }
    #pin-list.open { display: block; }

    .pin-card {
      background: rgba(255,255,255,0.03);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.4rem 0.6rem;
      margin-bottom: 0.35rem;
      font-size: 0.8rem;
    }
    .pin-card .pin-card-author {
      font-weight: 600;
      color: var(--accent);
      font-size: 0.75rem;
    }
    .pin-card .pin-card-body {
      color: var(--text);
      margin-top: 0.15rem;
      white-space: pre-wrap;
      word-wrap: break-word;
      max-height: 60px;
      overflow: hidden;
      cursor: pointer;
      transition: max-height 0.25s ease;
    }
    .pin-card.expanded .pin-card-body {
      max-height: none;
    }
    .pin-card .pin-expand-hint {
      font-size: 0.6rem;
      color: var(--text-muted);
      cursor: pointer;
      margin-top: 0.15rem;
      opacity: 0.7;
    }
    .pin-card .pin-expand-hint:hover { opacity: 1; }
    .pin-card.expanded .pin-expand-hint .hint-expand { display: none; }
    .pin-card:not(.expanded) .pin-expand-hint .hint-collapse { display: none; }
    .pin-card .pin-card-meta {
      font-size: 0.6rem;
      color: var(--text-muted);
      margin-top: 0.15rem;
    }
    .pin-card .pin-unpin {
      float: right;
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 0.7rem;
      padding: 0 0.3rem;
      border-radius: 3px;
    }
    .pin-card .pin-unpin:hover { color: var(--error, #e55); background: rgba(255,255,255,0.05); }
    .pin-section-header {
      font-size: 0.7rem;
      font-weight: 600;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
      margin-bottom: 0.3rem;
      padding-bottom: 0.2rem;
      border-bottom: 1px solid var(--border);
    }
    .pin-section-header:not(:first-child) { margin-top: 0.5rem; }

    /* ── @Mentions ── */
    .mention {
      background: rgba(224,112,32,0.15);
      color: var(--accent);
      padding: 0 0.2rem;
      border-radius: 3px;
    }
    .mention-me {
      background: rgba(224,112,32,0.3);
    }

    /* ── DM Section ── */
    .dm-section h4 {
      font-size: 0.65rem;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-top: 0.75rem;
      margin-bottom: 0.3rem;
      letter-spacing: 0.08em;
    }
    .dm-item {
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.78rem;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    .dm-item:hover { background: var(--bg-hover); }
    .dm-item.active {
      background: var(--accent-dim);
    }
    .dm-item .dm-name {
      font-weight: 600;
      color: var(--text);
      flex: 1;
      min-width: 0;
    }
    .dm-item .dm-preview {
      font-size: 0.68rem;
      color: var(--text-muted);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 120px;
    }
    .dm-item .dm-unread {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--accent);
      flex-shrink: 0;
    }
    .dm-item .dm-time {
      font-size: 0.6rem;
      color: var(--text-muted);
      white-space: nowrap;
    }

    /* DM message visual distinction */
    .message.dm-message {
      border-left: 3px solid var(--accent);
      background: rgba(224,112,32,0.04);
    }

    /* ── Sidebar Tab Bar ── */
    .sidebar-tabs {
      display: flex;
      gap: 2px;
      margin-bottom: 0.5rem;
      background: var(--bg);
      border-radius: 6px;
      padding: 2px;
    }
    .sidebar-tab {
      flex: 1;
      text-align: center;
      font-size: 0.65rem;
      padding: 4px 0;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 4px;
      cursor: pointer;
      color: var(--text-muted);
      background: transparent;
      border: none;
      font-family: inherit;
      transition: background 0.15s, color 0.15s;
      user-select: none;
      white-space: nowrap;
    }
    .sidebar-tab:hover { background: var(--bg-hover); color: var(--text); }
    .sidebar-tab.active {
      background: var(--accent-dim);
      color: var(--accent);
      font-weight: 600;
    }
    .sidebar-tab-content { display: none; }
    .sidebar-tab-content.active { display: block; }

    /* ── Server Group (collapsible) ── */
    .server-group { margin-bottom: 0.5rem; }
    .server-group-header {
      display: flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text);
      padding: 0.3rem 0.4rem;
      border-radius: 4px;
      cursor: pointer;
      user-select: none;
    }
    .server-group-header:hover { background: var(--bg-hover); }
    .server-group-header .collapse-arrow {
      font-size: 0.55rem;
      transition: transform 0.2s;
      color: var(--text-muted);
    }
    .server-group.collapsed .collapse-arrow { transform: rotate(-90deg); }
    .server-group.collapsed .server-group-channels { display: none; }
    .server-group-channels { padding-left: 0.2rem; }

    /* ── Groups Placeholder ── */
    .groups-placeholder {
      font-size: 0.7rem;
      color: var(--text-muted);
      padding: 0.3rem 0.5rem;
      font-style: italic;
    }

    /* ── Voice Call UI ── */
    #call-bar {
      display: none;
      background: linear-gradient(135deg, #1a3a2a, #1a2a3a);
      border-bottom: 1px solid var(--border);
      padding: 0.5rem 1rem;
      align-items: center;
      justify-content: space-between;
      gap: 0.5rem;
      font-size: 0.85rem;
      animation: noticeFadeIn 0.2s ease;
    }
    #call-bar.active { display: flex; }
    #call-bar .call-info {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--success);
      font-weight: 600;
    }
    #call-bar .call-timer {
      font-size: 0.75rem;
      color: var(--text-muted);
      font-family: monospace;
    }
    #call-bar .call-actions {
      display: flex;
      gap: 0.4rem;
    }
    #call-bar .call-actions button {
      border: none;
      padding: 0.35rem 0.7rem;
      border-radius: 5px;
      font-size: 0.78rem;
      cursor: pointer;
      font-weight: 600;
    }
    .btn-mute {
      background: var(--bg-input);
      color: var(--text);
      border: 1px solid var(--border) !important;
    }
    .btn-mute:hover { background: var(--bg-hover); }
    .btn-mute.muted { background: var(--warning); color: #000; }
    .btn-hangup {
      background: #dc3232;
      color: #fff;
    }
    .btn-hangup:hover { background: #e54545; }

    #incoming-call-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.7);
      z-index: 300;
      align-items: center;
      justify-content: center;
    }
    #incoming-call-overlay.open { display: flex; }
    #incoming-call-box {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 1.5rem 2rem;
      text-align: center;
      min-width: 280px;
      animation: noticeFadeIn 0.3s ease;
    }
    #incoming-call-box .call-icon {
      font-size: 2.5rem;
      margin-bottom: 0.5rem;
      animation: pulse 1s infinite;
    }
    #incoming-call-box .caller-name {
      font-size: 1.1rem;
      font-weight: 600;
      color: var(--text);
      margin-bottom: 0.3rem;
    }
    #incoming-call-box .call-label {
      font-size: 0.85rem;
      color: var(--text-muted);
      margin-bottom: 1rem;
    }
    #incoming-call-box .call-btns {
      display: flex;
      gap: 1rem;
      justify-content: center;
    }
    #incoming-call-box .call-btns button {
      border: none;
      padding: 0.6rem 1.5rem;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      font-weight: 600;
    }
    .btn-accept { background: var(--success); color: #fff; }
    .btn-accept:hover { filter: brightness(1.1); }
    .btn-reject { background: #dc3232; color: #fff; }
    .btn-reject:hover { filter: brightness(1.1); }

    .call-btn {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 0.75rem;
      padding: 0.1rem 0.25rem;
      border-radius: 3px;
      opacity: 0.5;
      transition: opacity 0.15s;
    }
    .call-btn:hover { opacity: 1; background: var(--bg-hover); }
    #ringing-status {
      display: none;
      text-align: center;
      color: var(--text-muted);
      font-size: 0.85rem;
      padding: 0.5rem;
      animation: pulse 1.5s infinite;
    }
    #ringing-status.active { display: block; }

    /* ── Code Blocks ── */
    .code-block-wrapper {
      position: relative;
      margin: 0.3rem 0;
    }
    .code-block-wrapper pre {
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 0.6rem 0.8rem;
      border-radius: 6px;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 0.82rem;
      line-height: 1.45;
      overflow-x: auto;
      white-space: pre;
      margin: 0;
      border: 1px solid #333;
    }
    .code-block-wrapper .code-lang {
      position: absolute;
      top: 0.2rem;
      right: 2.5rem;
      font-size: 0.6rem;
      color: #666;
      text-transform: uppercase;
    }
    .code-block-wrapper .code-copy {
      position: absolute;
      top: 0.2rem;
      right: 0.3rem;
      background: #333;
      border: 1px solid #555;
      color: #aaa;
      font-size: 0.65rem;
      padding: 0.1rem 0.4rem;
      border-radius: 3px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.15s;
    }
    .code-block-wrapper:hover .code-copy { opacity: 1; }
    .code-block-wrapper .code-copy:hover { color: #fff; border-color: var(--accent); }

    /* ── Blockquote (from markdown) ── */
    .body blockquote {
      border-left: 3px solid var(--accent);
      padding: 0.1rem 0 0.1rem 0.5rem;
      margin: 0.2rem 0;
      color: var(--text-muted);
      font-size: 0.85em;
    }
    .body ul.md-list {
      margin: 0.2rem 0 0.2rem 1.2rem;
      padding: 0;
      list-style: disc;
    }
    .body ul.md-list li {
      margin: 0.1rem 0;
    }

    /* ── Link Previews ── */
    .link-preview {
      border: 1px solid var(--border);
      border-left: 3px solid var(--accent);
      border-radius: 4px;
      padding: 0.4rem 0.6rem;
      margin: 0.3rem 0 0.3rem 1.6rem;
      font-size: 0.82rem;
      max-width: 500px;
      cursor: pointer;
      display: flex;
      gap: 0.5rem;
    }
    .link-preview:hover { background: var(--bg-hover); }
    .link-preview.collapsed { display: none; }
    .link-preview .lp-text { flex: 1; min-width: 0; }
    .link-preview .lp-site { font-size: 0.65rem; color: var(--text-muted); text-transform: uppercase; }
    .link-preview .lp-title { font-weight: 600; color: var(--accent); margin: 0.1rem 0; }
    .link-preview .lp-title a { color: var(--accent); text-decoration: none; }
    .link-preview .lp-title a:hover { text-decoration: underline; }
    .link-preview .lp-desc { color: var(--text-muted); font-size: 0.78rem; overflow: hidden; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; }
    .link-preview .lp-thumb { width: 80px; height: 60px; object-fit: cover; border-radius: 3px; flex-shrink: 0; }

    /* ── File Cards (documents, archives) ── */
    .file-card {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      background: var(--bg-hover);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.4rem 0.7rem;
      margin: 0.2rem 0;
      font-size: 0.82rem;
      max-width: 350px;
    }
    .file-card .file-icon { font-size: 1.3rem; }
    .file-card .file-info { flex: 1; min-width: 0; }
    .file-card .file-name { font-weight: 600; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .file-card .file-size { font-size: 0.7rem; color: var(--text-muted); }
    .file-card .file-download { color: var(--accent); text-decoration: none; font-size: 0.75rem; }
    .file-card .file-download:hover { text-decoration: underline; }

    /* ── Inline audio/video ── */
    .body audio { max-width: 100%; margin: 0.2rem 0; }
    .body video { max-width: 400px; max-height: 300px; border-radius: 4px; margin: 0.2rem 0; }

    /* ── Upload attachment button ── */
    #attach-btn {
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text-muted);
      padding: 0.55rem 0.6rem;
      border-radius: 6px;
      font-size: 1rem;
      cursor: pointer;
      flex-shrink: 0;
    }
    #attach-btn:hover { color: var(--accent); border-color: var(--accent); }

    /* ── Category Headers ── */
    .category-header {
      font-size: 0.62rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-muted);
      padding: 0.5rem 0.4rem 0.15rem;
      cursor: pointer;
      user-select: none;
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    .category-header:hover { color: var(--text); }
    .category-header .cat-arrow {
      font-size: 0.5rem;
      transition: transform 0.15s;
    }
    .category-header.collapsed .cat-arrow { transform: rotate(-90deg); }
    .category-header.collapsed + .category-channels { display: none; }

    /* ── Todo Channel Sections ── */
    .todo-section {
      border-radius: 8px;
      padding: 0.6rem 0.8rem;
      margin: 0.3rem 0;
    }
    .todo-section summary {
      cursor: pointer;
      font-weight: 700;
      font-size: 0.85rem;
      padding: 0.2rem 0;
      user-select: none;
      list-style: none;
    }
    .todo-section summary::-webkit-details-marker { display: none; }
    .todo-section summary::before {
      content: '▼ ';
      font-size: 0.7rem;
      margin-right: 0.3rem;
      display: inline-block;
      transition: transform 0.15s;
    }
    .todo-section:not([open]) summary::before {
      transform: rotate(-90deg);
    }
    .todo-section .todo-items {
      padding: 0.3rem 0 0 0.5rem;
      font-size: 0.85rem;
      line-height: 1.6;
      white-space: pre-wrap;
    }
    .todo-section.todo-active {
      background: #1a2a4a;
      border: 1px solid #2a3a5a;
    }
    .todo-section.todo-active summary { color: #6ab0ff; }
    .todo-section.todo-completed {
      background: #1a3a2a;
      border: 1px solid #2a4a3a;
    }
    .todo-section.todo-completed summary { color: #6adb8a; }
    .todo-section.todo-inactive {
      background: #3a1a1a;
      border: 1px solid #4a2a2a;
    }
    .todo-section.todo-inactive summary { color: #db6a6a; }

    /* ── Feature 1: Message Search ── */
    #search-bar {
      display: none;
      background: var(--bg-secondary);
      border-bottom: 1px solid var(--border);
      animation: noticeFadeIn 0.2s ease;
    }
    #search-bar.open { display: block; }
    #search-bar input {
      flex: 1;
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.4rem 0.6rem;
      border-radius: 5px;
      font-size: 0.85rem;
      outline: none;
      font-family: inherit;
    }
    #search-bar input:focus { border-color: var(--accent); }
    #search-bar .search-close {
      background: none;
      border: none;
      color: var(--text-muted);
      font-size: 1rem;
      cursor: pointer;
    }
    #search-bar .search-close:hover { color: var(--text); }
    #search-results {
      display: none;
      position: absolute;
      top: 100%;
      left: 0; right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-top: none;
      max-height: 400px;
      overflow-y: auto;
      z-index: 50;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
    #search-results.open { display: block; }
    .search-result {
      padding: 0.5rem 0.75rem;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      font-size: 0.82rem;
    }
    .search-result:hover { background: var(--bg-hover); }
    .search-result .sr-meta {
      display: flex;
      gap: 0.5rem;
      align-items: baseline;
      margin-bottom: 0.15rem;
    }
    .search-result .sr-author { font-weight: 600; color: var(--accent); }
    .search-result .sr-channel { color: var(--text-muted); font-size: 0.7rem; }
    .search-result .sr-time { color: var(--text-muted); font-size: 0.65rem; }
    .search-result .sr-body { color: var(--text); }
    .search-result .sr-body mark {
      background: rgba(224,112,32,0.3);
      color: var(--text);
      padding: 0 0.1rem;
      border-radius: 2px;
    }
    #search-toggle {
      background: none;
      border: none;
      color: var(--text);
      cursor: pointer;
      font-size: 1.1rem;
      padding: 0.2rem;
    }

    /* ── Feature 2 & 3: Voice Rooms & Video ── */
    .voice-rooms-section { margin-top: 0.75rem; }
    .voice-rooms-section h4 {
      font-size: 0.65rem;
      text-transform: uppercase;
      color: var(--text-muted);
      margin-bottom: 0.3rem;
      letter-spacing: 0.08em;
    }
    .voice-room-item {
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.78rem;
      margin-bottom: 0.2rem;
      background: rgba(255,255,255,0.02);
      border: 1px solid var(--border);
    }
    .voice-room-item:hover { border-color: var(--accent); }
    .voice-room-item .vr-name { font-weight: 600; color: var(--text); }
    .voice-room-item .vr-count { font-size: 0.65rem; color: var(--text-muted); }
    .voice-room-item .vr-participants {
      font-size: 0.7rem;
      color: var(--text-muted);
      padding-left: 0.5rem;
      margin-top: 0.15rem;
    }
    .voice-room-item .vr-participant { padding: 0.1rem 0; transition: color 0.15s, font-weight 0.15s; }
    .voice-room-item .vr-participant.speaking { color: #4a4; font-weight: bold; }
    .voice-room-item .vr-participant.speaking::before { content: '🟢 '; }
    .voice-room-item.in-room { border-color: var(--success); background: rgba(68,170,153,0.08); }

    /* ── Voice Control Bar ── */
    #voice-control-bar {
      display: none;
      background: linear-gradient(135deg, #1a3a2a, #1a2a3a);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem;
      margin-top: 0.5rem;
      font-size: 0.75rem;
    }
    #voice-control-bar.active { display: block; }
    #voice-control-bar .vc-bar-header {
      color: var(--success);
      font-weight: 600;
      font-size: 0.72rem;
      margin-bottom: 0.35rem;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }
    #voice-control-bar .vc-bar-controls {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    #voice-control-bar button {
      border: 1px solid var(--border);
      background: var(--bg-input);
      color: var(--text);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.72rem;
      cursor: pointer;
      white-space: nowrap;
    }
    #voice-control-bar button:hover { background: var(--bg-hover); }
    #voice-control-bar button.vc-muted { background: var(--warning); color: #000; }
    #voice-control-bar .vc-volume {
      flex: 1;
      min-width: 50px;
      accent-color: var(--accent);
      height: 16px;
    }
    #voice-control-bar .vc-disconnect {
      background: #dc3232;
      color: #fff;
      border-color: #dc3232;
    }
    #voice-control-bar .vc-disconnect:hover { background: #e54545; }

    /* ── Channel Settings Cog ── */
    .channel-cog {
      display: none;
      float: right;
      cursor: pointer;
      font-size: 0.7rem;
      opacity: 0.5;
      padding: 0 0.2rem;
      position: relative;
    }
    .channel-cog:hover { opacity: 1; }
    .channel-item:hover .channel-cog,
    .voice-room-item:hover .channel-cog { display: inline; }
    .cog-dropdown {
      position: absolute;
      right: 0;
      top: 100%;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      min-width: 130px;
      z-index: 200;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      padding: 0.3rem 0;
    }
    .cog-dropdown .cog-item {
      padding: 0.35rem 0.6rem;
      font-size: 0.78rem;
      color: var(--text);
      cursor: pointer;
      white-space: nowrap;
    }
    .cog-dropdown .cog-item:hover { background: var(--bg-hover); color: var(--accent); }
    .cog-dropdown .cog-item.danger { color: #e55; }
    .cog-dropdown .cog-item.danger:hover { background: rgba(220,50,50,0.15); }
    .voice-room-item.vc-empty { opacity: 0.55; }
    .voice-room-item.vc-empty:hover { opacity: 0.85; }
    .vr-delete { background: transparent !important; border: none !important; cursor: pointer; }
    .vr-create-btn {
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text-muted);
      padding: 0.3rem 0.5rem;
      border-radius: 4px;
      font-size: 0.72rem;
      cursor: pointer;
      width: 100%;
      margin-top: 0.3rem;
    }
    .vr-create-btn:hover { color: var(--accent); border-color: var(--accent); }
    .vr-leave-btn {
      background: #dc3232;
      color: #fff;
      border: none;
      padding: 0.2rem 0.5rem;
      border-radius: 3px;
      font-size: 0.68rem;
      cursor: pointer;
      margin-top: 0.2rem;
    }
    .vr-leave-btn:hover { background: #e54545; }

    /* Video panel */
    #video-panel {
      position: fixed;
      bottom: 80px;
      right: 20px;
      z-index: 1000;
      display: none;
      background: #111;
      border-radius: 8px;
      overflow: hidden;
      max-width: 640px;
    }
    #video-panel.active { display: flex; flex-wrap: wrap; gap: 2px; padding: 4px; }
    #video-panel .video-wrapper {
      position: relative;
      width: 200px;
      height: 150px;
    }
    #video-panel video {
      width: 200px;
      height: 150px;
      object-fit: cover;
      border-radius: 4px;
      background: #000;
    }
    #video-panel .video-label {
      position: absolute;
      bottom: 4px;
      left: 4px;
      font-size: 0.65rem;
      background: rgba(0,0,0,0.7);
      padding: 1px 4px;
      border-radius: 2px;
      color: #fff;
    }
    #video-panel .self-view {
      position: relative;
      width: 120px;
      height: 90px;
    }
    #video-panel .self-view video {
      width: 120px;
      height: 90px;
      transform: scaleX(-1);
    }
    /* Connection quality indicator */
    .vr-participant .quality-indicator { margin-left: 4px; font-size: 0.6rem; }
    .btn-video {
      background: var(--bg-input);
      color: var(--text);
      border: 1px solid var(--border) !important;
    }
    .btn-video:hover { background: var(--bg-hover); }
    .btn-video.active { background: var(--success); color: #000; }

    /* ── Feature 4: Message Deletion (enhanced) ── */
    .message-deleted-placeholder {
      color: var(--text-muted);
      font-style: italic;
      font-size: 0.78rem;
      padding: 0.2rem 0.4rem;
      opacity: 0.6;
      animation: fadeOutSlow 3s forwards;
    }
    @keyframes fadeOutSlow { 0% { opacity: 0.6; } 80% { opacity: 0.6; } 100% { opacity: 0; } }

    .delete-confirm {
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 0.5rem 0.75rem;
      font-size: 0.8rem;
      display: inline-flex;
      gap: 0.5rem;
      align-items: center;
      margin-top: 0.2rem;
    }
    .delete-confirm button {
      padding: 0.2rem 0.6rem;
      border-radius: 4px;
      font-size: 0.75rem;
      cursor: pointer;
      border: 1px solid var(--border);
    }
    .delete-confirm .confirm-yes { background: #dc3232; color: #fff; border-color: #dc3232; }
    .delete-confirm .confirm-yes:hover { background: #e54545; }
    .delete-confirm .confirm-no { background: var(--bg-input); color: var(--text-muted); }
    .delete-confirm .confirm-no:hover { color: var(--text); }

    /* ── Feature 5: User Status ── */
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.3rem;
      flex-shrink: 0;
    }
    .status-online { background: var(--success); }
    .status-away { background: #e0c860; }
    .status-busy { background: #dc3232; }
    .status-dnd { background: #dc3232; box-shadow: inset 0 0 0 1.5px #000; }
    .status-offline { background: #666; }

    .status-text-display {
      font-size: 0.65rem;
      color: var(--text-muted);
      font-style: italic;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 120px;
    }

    /* Status picker modal */
    #status-picker {
      display: none;
      position: fixed;
      background: var(--bg-secondary);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 0.75rem;
      z-index: 200;
      min-width: 220px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
    }
    #status-picker.open { display: block; }
    #status-picker h4 {
      font-size: 0.75rem;
      color: var(--text);
      margin-bottom: 0.5rem;
    }
    .status-option {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      padding: 0.3rem 0.4rem;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8rem;
      color: var(--text);
    }
    .status-option:hover { background: var(--bg-hover); }
    .status-option.active { background: var(--accent-dim); color: var(--accent); }
    .status-option .status-label { flex: 1; }
    #status-text-input {
      width: 100%;
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 0.35rem 0.5rem;
      border-radius: 4px;
      font-size: 0.78rem;
      outline: none;
      margin-top: 0.4rem;
      font-family: inherit;
    }
    #status-text-input:focus { border-color: var(--accent); }
    .status-clear-btn {
      background: var(--bg-input);
      border: 1px solid var(--border);
      color: var(--text-muted);
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-size: 0.7rem;
      cursor: pointer;
      margin-top: 0.3rem;
      width: 100%;
    }
    .status-clear-btn:hover { color: var(--text); border-color: var(--text-muted); }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/@twemoji/api@latest/dist/twemoji.min.js" crossorigin="anonymous"></script>
  <style>
    img.emoji {
      height: 1.2em;
      width: 1.2em;
      margin: 0 .05em 0 .1em;
      vertical-align: -0.2em;
      display: inline-block;
    }
  </style>
</head>
<body>
  <script src="/shared/shell.js"></script>
  <script src="/shared/settings.js"></script>

  <!-- Login Screen -->
  <div id="login-screen">
    <h1>🌍 Humanity Network</h1>
    <p>A cooperative communication platform.<br>No accounts. No tracking. Just people.</p>
    <input type="text" id="name-input" placeholder="Choose a name" autofocus>
    <input type="text" id="link-code-input" placeholder="Link code (optional)" style="margin-top:0.5rem; display:block;">
    <input type="text" id="invite-code-input" placeholder="Invite code (optional)" style="margin-top:0.5rem; display:block;">
    <button onclick="connect()">Enter</button>
    <button onclick="document.getElementById('import-file-input').click()" style="background:var(--bg-input);color:var(--text-muted);border:1px solid var(--border);padding:0.5rem 1.5rem;border-radius:6px;font-size:0.85rem;cursor:pointer;margin-top:0.3rem;">📥 Import Identity Backup</button>
    <input type="file" id="import-file-input" accept=".json" style="display:none;" onchange="handleImportFile(event)">
    <p class="subtitle" id="login-error" style="color:#e74c3c; display:none;"></p>
    <p class="subtitle" id="crypto-status">Checking Ed25519 support…</p>
    <p class="subtitle" style="margin-top: 1rem; font-size: 0.68rem; max-width: 380px; line-height: 1.5;">
      By entering, you confirm you are <strong style="color:var(--text);">18 years or older</strong> and agree to be respectful.<br>
      Your identity is a cryptographic key stored in your browser — <a href="https://shaostoul.com/Humanity/" target="_blank" rel="noopener" style="color:var(--accent);">learn more</a>.
    </p>
  </div>

  <!-- Chat Screen -->
  <div id="chat-screen">
    <header>
      <div class="header-left">
        <button id="hamburger" onclick="toggleSidebar('sidebar')">☰</button>
        <h1>🌍 Humanity</h1>
        <span id="stats"></span>
      </div>
      <div style="display:flex;align-items:center;gap:0.5rem;">
        <button id="search-toggle" onclick="toggleSearch()" title="Search messages">🔍</button>
        <button id="sound-toggle" onclick="toggleSoundMenu()" title="Notification sounds" style="background:none;border:none;color:var(--text);cursor:pointer;font-size:1.1rem;padding:0.2rem;">🔔</button>
        <button id="people-toggle" onclick="toggleSidebar('right-sidebar')" title="Users">👤</button>
        <div id="status" class="disconnected"><span class="dot"></span><span id="status-text">Disconnected</span></div>
      </div>
      <div id="sound-menu" style="display:none;position:absolute;top:3rem;right:5rem;background:var(--bg-secondary);border:1px solid var(--border);border-radius:8px;padding:0.6rem;z-index:200;min-width:200px;box-shadow:0 4px 12px rgba(0,0,0,0.3);">
        <div style="font-size:0.75rem;color:var(--text-muted);margin-bottom:0.4rem;font-weight:600;">NOTIFICATION SOUND</div>
        <div id="sound-options" style="display:flex;flex-direction:column;gap:0.25rem;"></div>
        <div style="border-top:1px solid var(--border);margin-top:0.5rem;padding-top:0.4rem;">
          <label style="font-size:0.75rem;color:var(--text);display:flex;align-items:center;gap:0.4rem;cursor:pointer;">
            <input type="checkbox" id="sound-enabled" checked onchange="toggleSoundEnabled()" style="accent-color:var(--accent);">
            Sounds enabled
          </label>
        </div>
      </div>
    </header>
    <div class="main">
      <div id="sidebar-overlay"></div>
      <div id="sidebar">
        <h3>Your Identity</h3>
        <div id="my-identity" style="font-size:0.7rem; color:var(--text-muted); margin-bottom:0.75rem; word-break:break-all;">
          <div id="my-key-display" style="font-family:monospace; font-size:0.6rem;"></div>
          <div id="my-sign-status" style="margin-top:0.2rem;"></div>
          <button id="edit-profile-btn" onclick="openEditProfileModal()" style="margin-top:0.4rem;background:var(--bg-input);border:1px solid var(--border);color:var(--text-muted);padding:0.25rem 0.5rem;border-radius:4px;font-size:0.7rem;cursor:pointer;width:100%;">✏️ Edit Profile</button>
          <button id="export-identity-btn" onclick="downloadIdentityBackup(myName)" style="margin-top:0.25rem;background:var(--bg-input);border:1px solid var(--border);color:var(--text-muted);padding:0.25rem 0.5rem;border-radius:4px;font-size:0.7rem;cursor:pointer;width:100%;">📥 Export Identity</button>
        </div>
        <div class="sidebar-tabs" id="sidebar-tabs">
          <button class="sidebar-tab active" data-tab="servers">🏠 Servers</button>
          <button class="sidebar-tab" data-tab="groups">👥 Groups</button>
          <button class="sidebar-tab" data-tab="dms">💬 DMs</button>
        </div>
        <div id="tab-servers" class="sidebar-tab-content active">
          <div id="server-list"></div>
        </div>
        <div id="tab-groups" class="sidebar-tab-content">
          <div class="groups-placeholder">P2P group chats — coming soon</div>
        </div>
        <div id="tab-dms" class="sidebar-tab-content">
          <div id="dm-list"></div>
        </div>
        <!-- Hidden channel-list container used by renderChannelList() -->
        <div id="channel-list" style="display:none;"></div>
        <!-- Voice Control Bar (shown when in a voice channel) -->
        <div id="voice-control-bar">
          <div class="vc-bar-header" id="vc-bar-channel-name">🔊 Connected</div>
          <div class="vc-bar-controls">
            <button id="vc-mute-btn" onclick="toggleVoiceRoomMute()" title="Mute/Unmute">🎤</button>
            <button id="vc-video-btn" onclick="toggleVoiceRoomVideo()" title="Toggle Camera">📹</button>
            <button id="vc-screen-btn" onclick="toggleVoiceRoomScreenShare()" title="Screen Share">🖥️</button>
            <input type="range" class="vc-volume" id="vc-volume-slider" min="0" max="100" value="100" title="Master volume" oninput="setVoiceRoomVolume(this.value)">
            <button class="vc-disconnect" onclick="leaveVoiceRoom()" title="Disconnect">🔌</button>
          </div>
        </div>
      </div>
      <div id="chat-area">
        <div id="search-bar" style="position:relative;">
          <div style="display:flex;gap:6px;align-items:center;padding:8px 12px;">
            <input type="text" id="search-input" placeholder="Search messages…" autocomplete="off" style="flex:1;">
            <input type="text" id="search-from" placeholder="From user…" autocomplete="off" style="width:120px;padding:6px 8px;background:var(--bg-secondary);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:0.85rem;">
            <span id="search-count" style="color:var(--text-muted);font-size:0.75rem;white-space:nowrap;"></span>
            <button class="search-close" onclick="closeSearch()">✕</button>
          </div>
          <div id="search-results"></div>
        </div>
        <div id="channel-header"></div>
        <div id="call-bar">
          <div class="call-info">
            <span>🔊</span>
            <span id="call-peer-name">In call</span>
            <span class="call-timer" id="call-timer">00:00</span>
          </div>
          <div class="call-actions">
            <button class="btn-mute" id="mute-btn" onclick="toggleMute()">🎤 Mute</button>
            <button class="btn-video" id="video-btn" onclick="toggleVideo()">📹 Video</button>
            <button class="btn-video" id="screen-btn" onclick="toggleScreenShare()">🖥️ Screen</button>
            <button class="btn-hangup" onclick="hangupCall()">📵 Hangup</button>
          </div>
        </div>
        <div id="ringing-status">📞 Calling…</div>
        <div id="pin-bar" onclick="togglePinList()">
          <span class="pin-summary"><span class="pin-icon">📌</span> <span id="pin-count">0</span> pinned — click to expand</span>
        </div>
        <div id="pin-list">
          <div id="server-pins-section" style="display:none;">
            <div class="pin-section-header">📌 Server Pins</div>
            <div id="server-pins"></div>
          </div>
          <div id="my-pins-section" style="display:none;">
            <div class="pin-section-header">⭐ My Pins</div>
            <div id="my-pins"></div>
          </div>
        </div>
        <div id="messages"></div>
        <div id="typing-indicator"></div>
        <div id="reply-bar" style="display:none;">
          <div id="reply-preview"></div>
          <button id="reply-cancel" title="Cancel reply">✕</button>
        </div>
        <div id="upload-indicator"></div>
        <div id="char-counter"></div>
        <div id="cmd-palette-overlay" onclick="closeCmdPalette()">
          <div id="cmd-palette" onclick="event.stopPropagation()"></div>
        </div>
        <div id="input-area">
          <button id="cmd-palette-btn" onclick="toggleCmdPalette()" title="Commands">+</button>
          <button id="attach-btn" onclick="document.getElementById('file-upload-input').click()" title="Attach file">📎</button>
          <input type="file" id="file-upload-input" style="display:none;" accept=".png,.jpg,.jpeg,.gif,.webp,.pdf,.txt,.md,.json,.zip,.tar.gz,.mp3,.mp4,.webm,.ogg,.wav" onchange="handleFileAttachment(event)">
          <textarea id="msg-input" placeholder="Type a message…" rows="1" disabled></textarea>
          <button id="send-btn" onclick="sendMessage()" disabled>Send</button>
          <button id="help-btn" onclick="toggleHelpModal()" title="Help & Commands">?</button>
        </div>
      </div>
      <div id="right-sidebar">
        <h3>Users</h3>
        <div id="peer-list"></div>
      </div>
    </div>
  </div>

  <!-- Help Modal -->
  <div id="help-modal-overlay" onclick="closeHelpModal(event)">
    <div id="help-modal" onclick="event.stopPropagation()">
      <button id="help-close" onclick="toggleHelpModal()">✕</button>
      <h2>📖 Commands & Help</h2>

      <h4>💬 Basic Commands</h4>
      <div class="cmd"><code>/help</code> — Show available commands</div>
      <div class="cmd"><code>/profile</code> — Open your profile editor (bio &amp; socials)</div>
      <div class="cmd"><code>/link</code> — Generate a code to link another device</div>
      <div class="cmd"><code>/revoke &lt;key_prefix&gt;</code> — Remove a lost/stolen device from your name</div>
      <div class="cmd"><code>/users</code> — List all registered users (online/offline)</div>
      <div class="cmd"><code>/report &lt;name&gt; [reason]</code> — Report a user</div>
      <div class="cmd"><code>/export</code> — Download your identity backup file</div>
      <div class="cmd"><code>/dm &lt;name&gt; &lt;message&gt;</code> — Send a direct message</div>
      <div class="cmd"><code>/dms</code> — List your DM conversations</div>
      <div class="cmd"><code>/block &lt;name&gt;</code> — Block a user (hides their messages)</div>
      <div class="cmd"><code>/unblock &lt;name&gt;</code> — Unblock a user</div>
      <div class="cmd"><code>/blocklist</code> — Show your blocked users</div>

      <h4>👥 Social</h4>
      <div class="cmd"><code>/follow &lt;name&gt;</code> — Follow a user (mutual follow = friends, unlocks DMs)</div>
      <div class="cmd"><code>/unfollow &lt;name&gt;</code> — Unfollow a user</div>
      <div class="cmd"><code>/friend-code</code> — Generate a friend code to share outside the platform</div>
      <div class="cmd"><code>/redeem &lt;code&gt;</code> — Redeem a friend code (auto-adds as friends)</div>

      <h4>👥 Groups</h4>
      <div class="cmd"><code>/group-create &lt;name&gt;</code> — Create a new group chat</div>
      <div class="cmd"><code>/group-join &lt;invite_code&gt;</code> — Join a group by invite code</div>
      <div class="cmd"><code>/group-invite</code> — Copy the current group's invite code</div>
      <div class="cmd"><code>/group-leave</code> — Leave the current group</div>

      <h4>✍️ Formatting</h4>
      <div class="cmd"><code>**bold**</code> → <strong>bold</strong></div>
      <div class="cmd"><code>*italic*</code> → <em>italic</em></div>
      <div class="cmd"><code>~~strike~~</code> → <del>strike</del></div>
      <div class="cmd"><code>`code`</code> → <code style="background:var(--bg-hover);padding:0.1rem 0.3rem;border-radius:3px;">code</code></div>
      <div class="cmd">Click ↩ on a message to quote-reply</div>
      <div class="cmd">Click ✏️ on your own message to edit it</div>
      <div class="cmd"><code>/edit &lt;text&gt;</code> — Edit your last message</div>
      <div class="cmd">Paste or drag an image to upload</div>

      <h4>📌 Pins</h4>
      <div class="cmd"><code>/pins</code> — List pinned messages in this channel</div>
      <div class="cmd"><code>/pin</code> — Pin the last message (mod/admin)</div>
      <div class="cmd"><code>/unpin &lt;N&gt;</code> — Unpin message by index (mod/admin)</div>

      <h4>🛡️ Moderator Commands</h4>
      <div class="cmd"><code>/kick &lt;name&gt;</code> — Disconnect a user</div>
      <div class="cmd"><code>/mute &lt;name&gt;</code> — Mute a user</div>
      <div class="cmd"><code>/unmute &lt;name&gt;</code> — Unmute a user</div>

      <h4>👑 Admin Commands</h4>
      <div class="cmd"><code>/ban &lt;name&gt;</code> — Ban a user</div>
      <div class="cmd"><code>/unban &lt;name&gt;</code> — Unban a user</div>
      <div class="cmd"><code>/mod &lt;name&gt;</code> — Make a user a moderator</div>
      <div class="cmd"><code>/unmod &lt;name&gt;</code> — Remove moderator role</div>
      <div class="cmd"><code>/verify &lt;name&gt;</code> — Mark user as verified</div>
      <div class="cmd"><code>/unverify &lt;name&gt;</code> — Remove verified status</div>
      <div class="cmd"><code>/lockdown</code> — Toggle registration lock</div>
      <div class="cmd"><code>/wipe</code> — Delete all chat history</div>
      <div class="cmd"><code>/gc</code> — Garbage collect inactive names (90 days)</div>
      <div class="cmd"><code>/channel-create &lt;name&gt; [--readonly] [desc]</code> — Create a channel</div>
      <div class="cmd"><code>/channel-delete &lt;name&gt;</code> — Delete a channel</div>
      <div class="cmd"><code>/channel-readonly &lt;name&gt;</code> — Toggle read-only on a channel</div>
      <div class="cmd"><code>/channel-reorder &lt;name&gt; &lt;pos&gt;</code> — Set channel sort position (lower = higher)</div>
      <div class="cmd"><code>/invite</code> — Generate an invite code for lockdown bypass</div>
      <div class="cmd"><code>/name-release &lt;name&gt;</code> — Release a name for re-registration</div>
      <div class="cmd"><code>/reports</code> — View recent reports</div>
      <div class="cmd"><code>/reports-clear</code> — Clear all reports</div>
    </div>
  </div>

  <!-- User Context Menu -->
  <div id="user-context-menu"></div>

  <!-- Edit Profile Modal -->
  <div id="edit-profile-overlay" class="profile-modal-overlay" onclick="closeEditProfileModal(event)">
    <div class="profile-modal" onclick="event.stopPropagation()">
      <button class="close-btn" onclick="closeEditProfileOverlay()">✕</button>
      <h2>✏️ Edit Profile</h2>
      <label for="profile-bio">Bio</label>
      <textarea id="profile-bio" rows="3" maxlength="280" placeholder="Tell people about yourself…"></textarea>
      <div class="bio-counter" id="bio-counter">0 / 280</div>
      <label for="profile-website">🌐 Website</label>
      <input type="text" id="profile-website" maxlength="200" placeholder="https://yoursite.com">
      <label for="profile-discord">💬 Discord</label>
      <input type="text" id="profile-discord" maxlength="100" placeholder="username">
      <label for="profile-twitter">𝕏 X / Twitter</label>
      <input type="text" id="profile-twitter" maxlength="100" placeholder="handle (without @)">
      <label for="profile-youtube">▶️ YouTube</label>
      <input type="text" id="profile-youtube" maxlength="200" placeholder="https://youtube.com/@channel or channel name">
      <label for="profile-github">🐙 GitHub</label>
      <input type="text" id="profile-github" maxlength="200" placeholder="username">
      <div class="btn-row">
        <button class="btn-cancel" onclick="closeEditProfileOverlay()">Cancel</button>
        <button class="btn-save" onclick="saveProfile()">Save</button>
      </div>
    </div>
  </div>

  <!-- Incoming Call Modal -->
  <div id="incoming-call-overlay">
    <div id="incoming-call-box">
      <div class="call-icon">📞</div>
      <div class="caller-name" id="incoming-caller-name">Someone</div>
      <div class="call-label">is calling you…</div>
      <div class="call-btns">
        <button class="btn-reject" onclick="rejectIncomingCall()">Reject</button>
        <button class="btn-accept" onclick="acceptIncomingCall()">Accept</button>
      </div>
    </div>
  </div>

  <!-- Video Panel -->
  <div id="video-panel"></div>

  <!-- Status Picker -->
  <div id="status-picker">
    <h4>Set Status</h4>
    <div class="status-option" data-status="online" onclick="setMyStatus('online')">
      <span class="status-indicator status-online"></span>
      <span class="status-label">Online</span>
    </div>
    <div class="status-option" data-status="away" onclick="setMyStatus('away')">
      <span class="status-indicator status-away"></span>
      <span class="status-label">Away</span>
    </div>
    <div class="status-option" data-status="busy" onclick="setMyStatus('busy')">
      <span class="status-indicator status-busy"></span>
      <span class="status-label">Busy</span>
    </div>
    <div class="status-option" data-status="dnd" onclick="setMyStatus('dnd')">
      <span class="status-indicator status-dnd"></span>
      <span class="status-label">Do Not Disturb</span>
    </div>
    <input type="text" id="status-text-input" placeholder="What are you up to?" maxlength="128">
    <button class="status-clear-btn" onclick="clearMyStatus()">Clear Status</button>
  </div>

  <!-- View Profile Modal -->
  <div id="view-profile-overlay" class="profile-modal-overlay" onclick="closeViewProfileModal(event)">
    <div class="profile-modal" id="view-profile-card" onclick="event.stopPropagation()">
      <button class="close-btn" onclick="closeViewProfileOverlay()">✕</button>
      <div id="view-profile-content">
        <div style="color:var(--text-muted);font-style:italic;">Loading profile…</div>
      </div>
    </div>
  </div>

  <script>
/**
 * Humanity Network — Client-side Ed25519 cryptography (inlined).
 * Uses Web Crypto API. Keys persisted in IndexedDB.
 */
const DB_NAME = 'humanity-keys';
const DB_VERSION = 1;
const STORE_NAME = 'identity';
const KEY_ID = 'primary';

function openKeyDB() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(DB_NAME, DB_VERSION);
    req.onupgradeneeded = () => { req.result.createObjectStore(STORE_NAME, { keyPath: 'id' }); };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function storeKeypair(db, publicKeyHex, keypair) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    tx.objectStore(STORE_NAME).put({ id: KEY_ID, publicKeyHex, privateKey: keypair.privateKey, publicKey: keypair.publicKey });
    tx.oncomplete = () => resolve();
    tx.onerror = () => reject(tx.error);
  });
}

async function loadKeypair(db) {
  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const req = tx.objectStore(STORE_NAME).get(KEY_ID);
    req.onsuccess = () => resolve(req.result || null);
    req.onerror = () => reject(req.error);
  });
}

function bufToHex(buf) {
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('');
}

function hexToBuf(hex) {
  const bytes = new Uint8Array(hex.length / 2);
  for (let i = 0; i < hex.length; i += 2) bytes[i / 2] = parseInt(hex.substr(i, 2), 16);
  return bytes;
}

async function supportsEd25519() {
  try { await crypto.subtle.generateKey('Ed25519', true, ['sign', 'verify']); return true; } catch (e) { return false; }
}

async function generateKeypair() {
  const keypair = await crypto.subtle.generateKey('Ed25519', true, ['sign', 'verify']);
  const rawPub = await crypto.subtle.exportKey('raw', keypair.publicKey);
  return { publicKeyHex: bufToHex(rawPub), privateKey: keypair.privateKey, publicKey: keypair.publicKey, isNew: true };
}

async function requestPersistentStorage() {
  try {
    if (navigator.storage && navigator.storage.persist) {
      const granted = await navigator.storage.persist();
      console.log('Persistent storage:', granted ? 'granted' : 'denied');
      return granted;
    }
  } catch (e) { console.warn('Persistent storage request failed:', e); }
  return false;
}

/** Save key backup to localStorage as redundancy (IndexedDB can be evicted). */
async function saveKeyBackupToLocalStorage(publicKeyHex, privateKey) {
  try {
    if (!privateKey) return;
    const exported = await crypto.subtle.exportKey('pkcs8', privateKey);
    const b64 = btoa(String.fromCharCode(...new Uint8Array(exported)));
    localStorage.setItem('humanity_key_backup', JSON.stringify({ publicKeyHex, privateKeyPkcs8: b64 }));
    console.log('Key backup saved to localStorage');
  } catch (e) { console.warn('Key backup to localStorage failed:', e); }
}

/** Try to restore key from localStorage backup. */
async function restoreKeyFromLocalStorage() {
  try {
    const raw = localStorage.getItem('humanity_key_backup');
    if (!raw) return null;
    const { publicKeyHex, privateKeyPkcs8 } = JSON.parse(raw);
    if (!publicKeyHex || !privateKeyPkcs8) return null;
    const pkcs8Buf = Uint8Array.from(atob(privateKeyPkcs8), c => c.charCodeAt(0));
    const privateKey = await crypto.subtle.importKey('pkcs8', pkcs8Buf, 'Ed25519', true, ['sign']);
    const publicKey = await crypto.subtle.importKey('raw', hexToBuf(publicKeyHex), 'Ed25519', true, ['verify']);
    console.log('Restored identity from localStorage backup:', publicKeyHex.substring(0, 16) + '…');
    // Re-save to IndexedDB
    try {
      const db = await openKeyDB();
      await storeKeypair(db, publicKeyHex, { privateKey, publicKey });
      console.log('Re-saved restored key to IndexedDB');
    } catch (e) { console.warn('Could not re-save to IndexedDB:', e); }
    return { publicKeyHex, privateKey, publicKey, canSign: true, isNew: false, restored: true };
  } catch (e) { console.warn('localStorage key restore failed:', e); return null; }
}

async function getOrCreateIdentity() {
  const hasEd25519 = await supportsEd25519();
  if (!hasEd25519) {
    console.warn('Ed25519 not supported — falling back to random key');
    let key = localStorage.getItem('humanity_key');
    if (!key) { const bytes = new Uint8Array(32); crypto.getRandomValues(bytes); key = bufToHex(bytes); localStorage.setItem('humanity_key', key); }
    return { publicKeyHex: key, privateKey: null, publicKey: null, canSign: false };
  }
  try {
    const db = await openKeyDB();
    const stored = await loadKeypair(db);
    if (stored && stored.privateKey && stored.publicKeyHex) {
      console.log('Loaded existing identity:', stored.publicKeyHex.substring(0, 16) + '…');
      // Ensure localStorage backup exists
      saveKeyBackupToLocalStorage(stored.publicKeyHex, stored.privateKey);
      return { publicKeyHex: stored.publicKeyHex, privateKey: stored.privateKey, publicKey: stored.publicKey, canSign: true, isNew: false };
    }
    // IndexedDB empty — try localStorage backup before generating new key
    const restored = await restoreKeyFromLocalStorage();
    if (restored) return restored;
    // Generate new identity
    const kp = await generateKeypair();
    await storeKeypair(db, kp.publicKeyHex, kp);
    // Request persistent storage for new identities
    await requestPersistentStorage();
    // Save backup to localStorage
    await saveKeyBackupToLocalStorage(kp.publicKeyHex, kp.privateKey);
    console.log('Generated new identity:', kp.publicKeyHex.substring(0, 16) + '…');
    return { publicKeyHex: kp.publicKeyHex, privateKey: kp.privateKey, publicKey: kp.publicKey, canSign: true, isNew: true };
  } catch (e) {
    console.error('Identity setup failed:', e);
    // Try localStorage backup as last resort
    const restored = await restoreKeyFromLocalStorage();
    if (restored) return restored;
    let key = localStorage.getItem('humanity_key');
    if (!key) { const bytes = new Uint8Array(32); crypto.getRandomValues(bytes); key = bufToHex(bytes); localStorage.setItem('humanity_key', key); }
    return { publicKeyHex: key, privateKey: null, publicKey: null, canSign: false };
  }
}

async function signMessage(privateKey, content, timestamp) {
  if (!privateKey) return null;
  try {
    const payload = `${content}\n${timestamp}`;
    const sig = await crypto.subtle.sign('Ed25519', privateKey, new TextEncoder().encode(payload));
    return bufToHex(sig);
  } catch (e) { console.error('Signing failed:', e); return null; }
}

async function verifyMessage(publicKeyHex, signatureHex, content, timestamp) {
  try {
    const pubKey = await crypto.subtle.importKey('raw', hexToBuf(publicKeyHex), 'Ed25519', true, ['verify']);
    const payload = `${content}\n${timestamp}`;
    return await crypto.subtle.verify('Ed25519', pubKey, hexToBuf(signatureHex), new TextEncoder().encode(payload));
  } catch (e) { console.error('Verification failed:', e); return false; }
}

// ── Identity Export/Import ──

/** Extract the 32-byte Ed25519 seed from a PKCS8 export. */
function extractSeedFromPkcs8(pkcs8Buf) {
  // PKCS8 for Ed25519: 48 bytes total. The 32-byte seed starts at offset 16.
  const bytes = new Uint8Array(pkcs8Buf);
  if (bytes.length === 48) {
    return bytes.slice(16, 48);
  }
  // Fallback: try last 32 bytes
  return bytes.slice(bytes.length - 32);
}

/** Export the current identity as a JSON backup object. Returns null if non-extractable. */
async function exportIdentityJSON(name) {
  if (!myIdentity || !myIdentity.privateKey) return null;
  try {
    const pkcs8 = await crypto.subtle.exportKey('pkcs8', myIdentity.privateKey);
    const seed = extractSeedFromPkcs8(pkcs8);
    const exportData = {
      name: name || myName,
      publicKey: myIdentity.publicKeyHex,
      privateKey: bufToHex(seed),
      exportedAt: new Date().toISOString(),
      note: "Keep this file safe. Anyone with it can impersonate you."
    };
    // Include ECDH key for E2EE DMs if available.
    if (myEcdhKeyPair) {
      try {
        const ecdhPkcs8 = await crypto.subtle.exportKey('pkcs8', myEcdhKeyPair.privateKey);
        exportData.ecdhPrivateKey = btoa(String.fromCharCode(...new Uint8Array(ecdhPkcs8)));
        exportData.ecdhPublicKey = myEcdhPublicBase64;
      } catch (e) { console.warn('ECDH export failed:', e); }
    }
    return exportData;
  } catch (e) {
    console.error('Export failed (key may be non-extractable):', e);
    return null;
  }
}

/** Download identity as a JSON file. */
async function downloadIdentityBackup(name) {
  const data = await exportIdentityJSON(name);
  if (!data) {
    addSystemMessage("⚠️ This key was created before backup support. Register a new name to get an exportable identity.");
    return false;
  }
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `humanity-identity-${data.name}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  return true;
}

/** Import an identity from a JSON backup file. Returns { publicKeyHex, privateKey, publicKey, name } or throws. */
async function importIdentityFromJSON(jsonData) {
  // Validate required fields
  if (!jsonData.publicKey || !jsonData.privateKey || !jsonData.name) {
    throw new Error("Invalid backup file: missing required fields (name, publicKey, privateKey).");
  }
  if (jsonData.publicKey.length !== 64 || jsonData.privateKey.length !== 64) {
    throw new Error("Invalid backup file: keys must be 64-character hex strings.");
  }

  // Reconstruct the Ed25519 keypair from the seed
  const seedBytes = hexToBuf(jsonData.privateKey);

  // Build PKCS8 wrapper around the 32-byte seed
  const pkcs8Prefix = new Uint8Array([
    0x30, 0x2e, 0x02, 0x01, 0x00, 0x30, 0x05, 0x06,
    0x03, 0x2b, 0x65, 0x70, 0x04, 0x22, 0x04, 0x20
  ]);
  const pkcs8 = new Uint8Array(48);
  pkcs8.set(pkcs8Prefix, 0);
  pkcs8.set(seedBytes, 16);

  const privateKey = await crypto.subtle.importKey(
    'pkcs8', pkcs8, 'Ed25519', true, ['sign']
  );

  // Import the public key
  const pubBytes = hexToBuf(jsonData.publicKey);
  const publicKey = await crypto.subtle.importKey(
    'raw', pubBytes, 'Ed25519', true, ['verify']
  );

  // Verify the imported keypair works by signing and verifying a test message
  const testMsg = new TextEncoder().encode('test');
  const testSig = await crypto.subtle.sign('Ed25519', privateKey, testMsg);
  const valid = await crypto.subtle.verify('Ed25519', publicKey, testSig, testMsg);
  if (!valid) {
    throw new Error("Key verification failed: the public and private keys don't match.");
  }

  // Store in IndexedDB
  const db = await openKeyDB();
  await storeKeypair(db, jsonData.publicKey, { privateKey, publicKey });

  // Set name in localStorage
  localStorage.setItem('humanity_name', jsonData.name);

  return {
    publicKeyHex: jsonData.publicKey,
    privateKey,
    publicKey,
    canSign: true,
    name: jsonData.name
  };
}

// ══════════════════════════════════════════════════════════════════════════════
// E2EE: ECDH P-256 + AES-256-GCM for end-to-end encrypted DMs
// ══════════════════════════════════════════════════════════════════════════════

const ECDH_DB_STORE = 'ecdh_identity';
let myEcdhKeyPair = null; // { publicKey, privateKey }
let myEcdhPublicBase64 = null; // base64-encoded raw public key for transmission

/** Generate or load ECDH P-256 keypair for E2EE DMs. */
async function getOrCreateEcdhKeypair() {
  try {
    // Try loading from IndexedDB
    const db = await openKeyDB();
    const stored = await new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const req = tx.objectStore(STORE_NAME).get('ecdh');
      req.onsuccess = () => resolve(req.result || null);
      req.onerror = () => reject(req.error);
    });
    if (stored && stored.privateKey && stored.publicKey) {
      myEcdhKeyPair = { privateKey: stored.privateKey, publicKey: stored.publicKey };
      const raw = await crypto.subtle.exportKey('raw', stored.publicKey);
      myEcdhPublicBase64 = btoa(String.fromCharCode(...new Uint8Array(raw)));
      console.log('Loaded existing ECDH key');
      return;
    }
  } catch (e) { console.warn('ECDH IndexedDB load failed:', e); }

  // Try localStorage backup
  try {
    const backup = localStorage.getItem('humanity_ecdh_backup');
    if (backup) {
      const { publicKeyRaw, privateKeyPkcs8 } = JSON.parse(backup);
      const privBuf = Uint8Array.from(atob(privateKeyPkcs8), c => c.charCodeAt(0));
      const pubBuf = Uint8Array.from(atob(publicKeyRaw), c => c.charCodeAt(0));
      const privateKey = await crypto.subtle.importKey('pkcs8', privBuf, { name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey']);
      const publicKey = await crypto.subtle.importKey('raw', pubBuf, { name: 'ECDH', namedCurve: 'P-256' }, true, []);
      myEcdhKeyPair = { privateKey, publicKey };
      myEcdhPublicBase64 = publicKeyRaw;
      console.log('Restored ECDH key from localStorage');
      // Re-save to IndexedDB
      try {
        const db = await openKeyDB();
        const tx = db.transaction(STORE_NAME, 'readwrite');
        tx.objectStore(STORE_NAME).put({ id: 'ecdh', privateKey, publicKey });
      } catch (e) {}
      return;
    }
  } catch (e) { console.warn('ECDH localStorage restore failed:', e); }

  // Generate new
  try {
    const kp = await crypto.subtle.generateKey({ name: 'ECDH', namedCurve: 'P-256' }, true, ['deriveKey']);
    myEcdhKeyPair = { privateKey: kp.privateKey, publicKey: kp.publicKey };
    const raw = await crypto.subtle.exportKey('raw', kp.publicKey);
    myEcdhPublicBase64 = btoa(String.fromCharCode(...new Uint8Array(raw)));

    // Store in IndexedDB
    try {
      const db = await openKeyDB();
      const tx = db.transaction(STORE_NAME, 'readwrite');
      tx.objectStore(STORE_NAME).put({ id: 'ecdh', privateKey: kp.privateKey, publicKey: kp.publicKey });
    } catch (e) {}

    // Backup to localStorage
    try {
      const pkcs8 = await crypto.subtle.exportKey('pkcs8', kp.privateKey);
      const pkcs8B64 = btoa(String.fromCharCode(...new Uint8Array(pkcs8)));
      localStorage.setItem('humanity_ecdh_backup', JSON.stringify({ publicKeyRaw: myEcdhPublicBase64, privateKeyPkcs8: pkcs8B64 }));
    } catch (e) {}

    console.log('Generated new ECDH P-256 keypair');
  } catch (e) {
    console.error('ECDH key generation failed:', e);
  }
}

/** Derive an AES-GCM-256 key from our ECDH private key and peer's ECDH public key. */
async function deriveSharedKey(peerEcdhPublicBase64) {
  if (!myEcdhKeyPair || !peerEcdhPublicBase64) return null;
  try {
    const peerRaw = Uint8Array.from(atob(peerEcdhPublicBase64), c => c.charCodeAt(0));
    const peerKey = await crypto.subtle.importKey('raw', peerRaw, { name: 'ECDH', namedCurve: 'P-256' }, false, []);
    return await crypto.subtle.deriveKey(
      { name: 'ECDH', public: peerKey },
      myEcdhKeyPair.privateKey,
      { name: 'AES-GCM', length: 256 },
      false,
      ['encrypt', 'decrypt']
    );
  } catch (e) {
    console.error('ECDH key derivation failed:', e);
    return null;
  }
}

/** Encrypt a plaintext string for a peer. Returns { content, nonce } (both base64) or null. */
async function encryptDmContent(plaintext, peerEcdhPublicBase64) {
  const sharedKey = await deriveSharedKey(peerEcdhPublicBase64);
  if (!sharedKey) return null;
  try {
    const iv = crypto.getRandomValues(new Uint8Array(12));
    const encoded = new TextEncoder().encode(plaintext);
    const ciphertext = await crypto.subtle.encrypt({ name: 'AES-GCM', iv }, sharedKey, encoded);
    return {
      content: btoa(String.fromCharCode(...new Uint8Array(ciphertext))),
      nonce: btoa(String.fromCharCode(...iv))
    };
  } catch (e) {
    console.error('DM encryption failed:', e);
    return null;
  }
}

/** Decrypt an encrypted DM. Returns plaintext string or null. */
async function decryptDmContent(ciphertextBase64, nonceBase64, peerEcdhPublicBase64) {
  const sharedKey = await deriveSharedKey(peerEcdhPublicBase64);
  if (!sharedKey) return null;
  try {
    const iv = Uint8Array.from(atob(nonceBase64), c => c.charCodeAt(0));
    const ciphertext = Uint8Array.from(atob(ciphertextBase64), c => c.charCodeAt(0));
    const plainBuf = await crypto.subtle.decrypt({ name: 'AES-GCM', iv }, sharedKey, ciphertext);
    return new TextDecoder().decode(plainBuf);
  } catch (e) {
    console.error('DM decryption failed:', e);
    return null;
  }
}

/** Look up ECDH public key for a peer by their Ed25519 public key. */
function getPeerEcdhPublic(peerKey) {
  const peer = peerData[peerKey];
  return peer ? peer.ecdh_public : null;
}

// ══════════════════════════════════════════════════════════════════════════════
// End E2EE
// ══════════════════════════════════════════════════════════════════════════════
  </script>
  <script>
    // Parse static emoji on page load — skip hub-nav so emoji match other pages
    document.addEventListener('DOMContentLoaded', () => {
      if (window.twemoji) {
        document.querySelectorAll('#login-screen, #chat-screen').forEach(el => twemoji.parse(el));
      }
    });

    // ── State ──
    let ws = null;
    let myKey = '';
    let myName = '';
    let myIdentity = null; // { publicKeyHex, privateKey, publicKey, canSign }
    let reconnectTimer = null;
    let reconnectDelay = 1000;
    const MAX_RECONNECT_DELAY = 30000;
    let seenTimestamps = new Set(); // Deduplicate messages

    // Persist name across sessions — auto-login if returning user.
    const savedName = localStorage.getItem('humanity_name');
    if (savedName) {
      document.getElementById('name-input').value = savedName;
      // Skip login screen immediately — show chat with "Connecting..." status.
      document.getElementById('login-screen').style.display = 'none';
      document.getElementById('chat-screen').style.display = 'flex';
      setStatus('reconnecting', 'Connecting…');
      // Auto-connect after a tick (let DOM settle).
      setTimeout(() => connect(), 50);
    }

    let pendingLinkCode = null;
    let pendingInviteCode = null;
    let identityConfirmed = false;
    let activeChannel = localStorage.getItem('humanity_channel') || 'general';
    let channelList = [];
    let replyTarget = null; // { author, body, fromKey, timestamp, element }

    // ── Reply Bar ──
    function setReplyTarget(author, body, fromKey, timestamp, element) {
      const shortBody = body.length > 80 ? body.substring(0, 80) + '…' : body;
      replyTarget = { author, body, fromKey, timestamp, element };
      const bar = document.getElementById('reply-bar');
      document.getElementById('reply-preview').innerHTML =
        `<span class="reply-author">${esc(author)}</span> ${esc(shortBody)}`;
      bar.style.display = 'flex';
      if (window.twemoji) twemoji.parse(bar);
    }

    function clearReplyTarget() {
      replyTarget = null;
      document.getElementById('reply-bar').style.display = 'none';
      document.getElementById('reply-preview').innerHTML = '';
    }

    // Click reply preview → scroll to the original message.
    document.getElementById('reply-preview').addEventListener('click', () => {
      if (replyTarget && replyTarget.element) {
        replyTarget.element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        // Brief highlight effect.
        replyTarget.element.style.background = 'var(--accent-dim)';
        setTimeout(() => { replyTarget.element.style.background = ''; }, 1500);
      }
    });

    // Cancel reply.
    document.getElementById('reply-cancel').addEventListener('click', (e) => {
      e.stopPropagation();
      clearReplyTarget();
      document.getElementById('msg-input').focus();
    });

    // Event delegation: handle clicks on image placeholders (data-img-url).
    document.getElementById('messages').addEventListener('click', function(e) {
      const placeholder = e.target.closest('[data-img-url]');
      if (placeholder) {
        loadImage(placeholder, placeholder.dataset.imgUrl);
        return;
      }
      // Handle clicks on reaction badges (data-target-from).
      const badge = e.target.closest('[data-target-from]');
      if (badge) {
        sendReaction(badge.dataset.targetFrom, Number(badge.dataset.targetTs), badge.dataset.emoji);
      }
    });

    // ── Connect ──
    async function connect() {
      myName = document.getElementById('name-input').value.trim() || 'Anonymous';
      pendingLinkCode = document.getElementById('link-code-input').value.trim() || null;
      pendingInviteCode = document.getElementById('invite-code-input').value.trim() || null;

      // Validate name: only ASCII letters, numbers, underscores, dashes. Max 24 chars.
      if (!/^[A-Za-z0-9_-]{1,24}$/.test(myName)) {
        const errEl = document.getElementById('login-error');
        errEl.textContent = 'Names can only contain letters (A-Z), numbers, underscores, and dashes. Max 24 characters.';
        errEl.style.display = 'block';
        return;
      }

      localStorage.setItem('humanity_name', myName);

      // Hide any previous error, show connecting status.
      document.getElementById('login-error').style.display = 'none';
      document.getElementById('crypto-status').textContent = 'Connecting…';
      document.getElementById('crypto-status').style.color = 'var(--text-muted)';

      // Initialize Ed25519 identity.
      myIdentity = await getOrCreateIdentity();
      myKey = myIdentity.publicKeyHex;

      // Initialize ECDH P-256 keypair for E2E encrypted DMs.
      await getOrCreateEcdhKeypair();

      // Stay on login screen — we switch to chat only after server confirms identity.
      identityConfirmed = false;
      openSocket();
    }

    // ── User Data Sync ──
    const SYNC_KEYS = [
      'humanity_settings', 'humanity_notes', 'humanity_todos', 'humanity_garden',
      'humanity_blocked', 'humanity_pins', 'humanity_default_tab',
      'footer_collapsed', 'sidebar_tab'
    ];
    let syncDebounceTimer = null;
    let syncInitialized = false;

    function getSyncBlob() {
      const blob = {};
      for (const key of SYNC_KEYS) {
        const val = localStorage.getItem(key);
        if (val !== null) blob[key] = val;
      }
      return JSON.stringify(blob);
    }

    function applySyncBlob(jsonStr) {
      try {
        const blob = JSON.parse(jsonStr);
        for (const key of SYNC_KEYS) {
          if (key in blob) {
            localStorage.setItem(key, blob[key]);
          }
        }
        // Re-apply settings if they changed.
        if (blob.humanity_settings && window.humanitySettings) {
          try {
            const s = JSON.parse(blob.humanity_settings);
            if (typeof applySettings === 'function') applySettings(s);
          } catch (e) {}
        }
      } catch (e) {
        console.warn('Failed to apply sync blob:', e);
      }
    }

    function scheduleSyncSave() {
      if (!syncInitialized) return;
      clearTimeout(syncDebounceTimer);
      syncDebounceTimer = setTimeout(() => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const data = getSyncBlob();
        const now = Date.now();
        localStorage.setItem('sync_updated_at', String(now));
        ws.send(JSON.stringify({ type: 'sync_save', data: data }));
      }, 5000);
    }

    function handleSyncData(payload) {
      if (payload === 'null') {
        // No server data — push local data to server.
        syncInitialized = true;
        scheduleSyncSave();
        return;
      }
      try {
        const resp = JSON.parse(payload);
        const serverData = resp.data;
        const serverUpdatedAt = resp.updated_at || 0;
        const localUpdatedAt = parseInt(localStorage.getItem('sync_updated_at') || '0', 10);

        if (!localUpdatedAt || localUpdatedAt < serverUpdatedAt) {
          // Server is newer — apply server data.
          applySyncBlob(serverData);
          localStorage.setItem('sync_updated_at', String(serverUpdatedAt));
        } else {
          // Local is newer or equal — push to server.
          setTimeout(() => scheduleSyncSave(), 1000);
        }
      } catch (e) {
        console.warn('Sync data parse error:', e);
      }
      syncInitialized = true;
    }

    function requestSyncLoad() {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({ type: 'sync_load' }));
    }

    // Watch localStorage changes — intercept setItem to detect changes.
    (function() {
      const origSetItem = localStorage.setItem.bind(localStorage);
      localStorage.setItem = function(key, value) {
        origSetItem(key, value);
        if (SYNC_KEYS.includes(key)) {
          scheduleSyncSave();
        }
      };
    })();

    // Called once the server accepts our identity (sends peer_list).
    function onIdentityConfirmed() {
      if (identityConfirmed) return;
      identityConfirmed = true;

      document.getElementById('login-screen').style.display = 'none';
      document.getElementById('chat-screen').style.display = 'flex';

      // Show identity in sidebar.
      document.getElementById('my-key-display').textContent = myKey;
      document.getElementById('my-sign-status').innerHTML = myIdentity.canSign
        ? '<span style="color:var(--success)">✓ Signing enabled</span>'
        : '<span style="color:var(--warning)">⚠ Unsigned mode</span>';

      // Auto-download identity backup on first registration.
      if (myIdentity && myIdentity.isNew) {
        myIdentity.isNew = false; // Only trigger once
        setTimeout(async () => {
          const ok = await downloadIdentityBackup(myName);
          if (ok) {
            addNotice("🔑 IMPORTANT: Your identity file was downloaded. This is your ONLY recovery method if browser data is cleared. Save it somewhere safe (cloud drive, USB, email to yourself). Without it, your identity is GONE forever.", 'red', 120);
          }
          // Request persistent storage
          requestPersistentStorage();
        }, 1500);
      }

      // Notify if identity was restored from backup
      if (myIdentity && myIdentity.restored) {
        addNotice("🔑 Your identity was restored from a local backup. Your IndexedDB was cleared but we recovered your key. Please export a backup file for safety.", 'yellow', 30);
      }

      // Request persistent storage to prevent browser eviction of keys.
      requestPersistentStorage();

      // Request notification permission once.
      requestNotifications();

      // Sync profile to server on connect.
      try { syncProfileOnConnect(); } catch (e) { console.warn('Profile sync error:', e); }

      // Request user data sync from server.
      requestSyncLoad();

      // Don't load history here — wait for channel_list to arrive,
      // then switchChannel will load it.
      // If channel_list already arrived, load now.
      if (channelList.length > 0) {
        switchChannel(activeChannel);
      } else {
        // Fallback: load history for current channel, then reactions.
        loadHistory().then(() => loadReactionsForChannel(activeChannel));
      }
    }

    // ── History ──
    async function loadHistory() {
      try {
        const resp = await fetch(`/api/messages?limit=100&channel=${encodeURIComponent(activeChannel)}`);
        const data = await resp.json();
        if (data.messages && data.messages.length > 0) {
          const notice = document.createElement('div');
          notice.id = 'history-notice';
          notice.textContent = `── ${data.messages.length} earlier messages ──`;
          document.getElementById('messages').appendChild(notice);

          // "New messages" divider: show where user left off last time.
          const lastSeen = parseInt(localStorage.getItem('humanity_last_seen') || '0');
          let newMsgDividerShown = false;

          let lastDate = '';
          for (const msg of data.messages) {
            const msgDate = new Date(msg.timestamp).toLocaleDateString();
            if (msgDate !== lastDate) {
              addDateSeparator(msgDate);
              lastDate = msgDate;
            }

            // Insert "New messages" divider before first unseen message.
            if (!newMsgDividerShown && lastSeen > 0 && msg.timestamp > lastSeen && msg.from !== myKey) {
              const divider = document.createElement('div');
              divider.className = 'new-messages-divider';
              divider.textContent = 'New messages';
              document.getElementById('messages').appendChild(divider);
              newMsgDividerShown = true;
            }

            const key = msg.from + ':' + msg.timestamp;
            seenTimestamps.add(key);
            addChatMessage(
              msg.from_name || shortKey(msg.from),
              msg.content,
              msg.timestamp,
              msg.from,
              true, // isHistory
              !!msg.signature
            );
          }

          // Update last-seen to the newest message timestamp.
          const newest = data.messages[data.messages.length - 1];
          if (newest) localStorage.setItem('humanity_last_seen', String(newest.timestamp));
        }
      } catch (e) {
        console.warn('Failed to load history:', e);
      }
    }

    // ── WebSocket ──
    function openSocket() {
      if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
        return;
      }

      const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
      ws = new WebSocket(`${proto}//${location.host}/ws`);

      ws.onopen = () => {
        reconnectDelay = 1000;
        clearTimeout(reconnectTimer);

        const identifyMsg = {
          type: 'identify',
          public_key: myKey,
          display_name: myName,
        };
        // E2EE: Include ECDH public key for end-to-end encrypted DMs.
        if (myEcdhPublicBase64) {
          identifyMsg.ecdh_public = myEcdhPublicBase64;
        }
        if (pendingLinkCode) {
          identifyMsg.link_code = pendingLinkCode;
          pendingLinkCode = null;
        }
        if (pendingInviteCode) {
          identifyMsg.invite_code = pendingInviteCode;
          pendingInviteCode = null;
        }
        ws.send(JSON.stringify(identifyMsg));

        // Don't switch screens yet — wait for server to confirm via peer_list.
        // If already confirmed (reconnect), re-enable input.
        if (identityConfirmed) {
          setStatus('connected', 'Connected');
          document.getElementById('msg-input').disabled = false;
          document.getElementById('send-btn').disabled = false;
          document.getElementById('msg-input').focus();
          updateStats();
        }
      };

      ws.onmessage = (event) => {
        try {
          const msg = JSON.parse(event.data);
          handleMessage(msg);
        } catch (e) {
          console.error('Message handler error:', e, event.data?.slice?.(0, 200));
        }
      };

      ws.onclose = () => {
        setStatus('disconnected', 'Disconnected');
        document.getElementById('msg-input').disabled = true;
        document.getElementById('send-btn').disabled = true;
        scheduleReconnect();
      };

      ws.onerror = () => {
        // onclose will fire after this.
      };
    }

    function scheduleReconnect() {
      clearTimeout(reconnectTimer);
      setStatus('reconnecting', `Reconnecting in ${Math.round(reconnectDelay/1000)}s…`);
      reconnectTimer = setTimeout(() => {
        setStatus('reconnecting', 'Reconnecting…');
        openSocket();
        reconnectDelay = Math.min(reconnectDelay * 1.5, MAX_RECONNECT_DELAY);
      }, reconnectDelay);
    }

    // ── Message Handling ──
    function handleMessage(msg) {
      switch (msg.type) {
        case 'chat': {
          // Only show messages for the active channel.
          const msgChannel = msg.channel || 'general';
          if (msgChannel !== activeChannel) return;
          const key = msg.from + ':' + msg.timestamp;
          if (seenTimestamps.has(key)) return; // Deduplicate
          seenTimestamps.add(key);
          const hasSig = !!msg.signature;
          // If message has a signature, verify it client-side.
          if (hasSig && msg.signature && msg.from && !msg.from.startsWith('bot_')) {
            verifyMessage(msg.from, msg.signature, msg.content, msg.timestamp).then(valid => {
              addChatMessage(msg.from_name || shortKey(msg.from), msg.content, msg.timestamp, msg.from, false, valid);
            });
          } else {
            addChatMessage(msg.from_name || shortKey(msg.from), msg.content, msg.timestamp, msg.from, false, hasSig);
          }
          break;
        }
        case 'peer_joined':
          // Update peerData with new peer info — sidebar handles visibility.
          peerData[msg.public_key] = { public_key: msg.public_key, display_name: msg.display_name, role: msg.role || '', ecdh_public: msg.ecdh_public || null };
          updateStats();
          break;
        case 'peer_left':
          // Keep ecdh_public in peerData for offline decryption of history
          if (peerData[msg.public_key]) {
            peerData[msg.public_key]._offline = true;
          }
          updateStats();
          break;
        case 'channel_list':
          updateChannelList(msg.channels || []);
          updateChannelHeader();
          updateInputForChannel();
          break;
        case 'peer_list':
          // Auto-reload on server update: if server_version changed, unregister SW and refresh.
          if (msg.server_version) {
            if (!window._serverVersion) {
              window._serverVersion = msg.server_version;
            } else if (window._serverVersion !== msg.server_version) {
              console.log('Server updated, clearing SW cache and reloading…');
              if ('serviceWorker' in navigator) {
                navigator.serviceWorker.getRegistrations().then(regs => {
                  regs.forEach(r => r.unregister());
                  if ('caches' in window) caches.keys().then(ks => ks.forEach(k => caches.delete(k)));
                  setTimeout(() => location.reload(), 200);
                }).catch(() => location.reload());
              } else {
                location.reload();
              }
              return;
            }
          }
          // Server sent peer_list = identity accepted!
          if (!identityConfirmed) {
            onIdentityConfirmed();
          }
          // Always re-enable input and update status (handles reconnects too).
          setStatus('connected', 'Connected');
          document.getElementById('msg-input').disabled = false;
          document.getElementById('send-btn').disabled = false;
          document.getElementById('msg-input').focus();
          updateStats();
          updatePeerList(msg.peers);
          break;
        case 'full_user_list':
          updateUserList(msg.users || []);
          break;
        case 'typing': {
          // Show "X is typing…" indicator, clear after 3 seconds.
          const typerName = msg.from_name || shortKey(msg.from);
          showTypingIndicator(typerName);
          break;
        }
        case 'reaction': {
          applyReaction(msg.target_from, msg.target_timestamp, msg.emoji, msg.from, msg.from_name);
          break;
        }
        case 'reactions_sync': {
          if (msg.reactions && msg.reactions.length > 0) {
            for (const r of msg.reactions) {
              applyReactionSync(r.target_from, r.target_timestamp, r.emoji, r.reactor_key);
            }
          }
          break;
        }
        case 'delete': {
          // Remove the deleted message from the DOM.
          const msgs = document.querySelectorAll('.message[data-from="' + msg.from + '"][data-timestamp="' + msg.timestamp + '"]');
          msgs.forEach(m => m.remove());
          break;
        }
        case 'edit': {
          // Update the edited message in the DOM.
          applyEditToDOM(msg.from, msg.timestamp, msg.new_content);
          break;
        }
        case 'pins_sync': {
          // Full pin list for a channel.
          if (msg.channel === activeChannel) {
            currentPins = msg.pins || [];
            renderPinBar();
          }
          break;
        }
        case 'pin_added': {
          if (msg.channel === activeChannel) {
            currentPins.push(msg.pin);
            renderPinBar();
          }
          break;
        }
        case 'pin_removed': {
          if (msg.channel === activeChannel) {
            // Remove by 1-based index.
            const idx = msg.index - 1;
            if (idx >= 0 && idx < currentPins.length) {
              currentPins.splice(idx, 1);
            }
            renderPinBar();
          }
          break;
        }
        case 'profile_data': {
          // Cache profile data and show if we were waiting for it.
          if (msg.name) {
            profileCache[msg.name.toLowerCase()] = { bio: msg.bio || '', socials: msg.socials || '{}' };
            // If we have a pending view for this user, show it.
            if (pendingProfileView && pendingProfileView.name.toLowerCase() === msg.name.toLowerCase()) {
              showViewProfileCard(pendingProfileView.name, pendingProfileView.publicKey, msg.bio || '', msg.socials || '{}');
              pendingProfileView = null;
            }
            // If this is our own profile data on connect, update local storage.
            if (msg.name.toLowerCase() === myName.toLowerCase()) {
              try {
                const socials = JSON.parse(msg.socials || '{}');
                // Only overwrite local if server has data and local is empty.
                const local = loadProfileLocal();
                if ((!local.bio && !local.socials) || (Object.keys(local.socials || {}).length === 0 && !local.bio)) {
                  saveProfileLocal(msg.bio || '', socials);
                }
              } catch {}
            }
          }
          break;
        }
        case 'dm': {
          // Incoming DM — if we're viewing this conversation, show it.
          const dmFrom = msg.from;
          const dmFromName = msg.from_name || shortKey(dmFrom);
          let dmContent = msg.content;
          let dmIsEncrypted = !!msg.encrypted;
          // E2EE: Decrypt if encrypted.
          if (msg.encrypted && msg.nonce) {
            const senderEcdh = getPeerEcdhPublic(dmFrom);
            if (senderEcdh) {
              const plain = await decryptDmContent(msg.content, msg.nonce, senderEcdh);
              if (plain !== null) {
                dmContent = plain;
              } else {
                dmContent = '🔒 [Decryption failed]';
              }
            } else {
              dmContent = '🔒 [Cannot decrypt — missing sender key]';
            }
          }
          if (activeDmPartner && (dmFrom === activeDmPartner || dmFrom === myKey)) {
            addDmMessage(dmFromName, dmContent, msg.timestamp, dmFrom, msg.to, dmIsEncrypted);
          }
          // Notify.
          if (dmFrom !== myKey) {
            notifyNewMessage(dmFromName, dmIsEncrypted ? '🔒 Encrypted message' : dmContent, true);
          }
          break;
        }
        case 'dm_list': {
          dmConversations = msg.conversations || [];
          renderDmList();
          break;
        }
        case 'dm_history': {
          // Received conversation history for a DM.
          if (activeDmPartner === msg.partner) {
            document.getElementById('messages').innerHTML = '';
            const msgs = msg.messages || [];
            // E2EE status banner
            const partnerEcdh = getPeerEcdhPublic(msg.partner);
            const e2eeNotice = document.createElement('div');
            e2eeNotice.style.cssText = 'text-align:center;font-size:0.7rem;padding:0.3rem;color:var(--text-muted);';
            if (partnerEcdh && myEcdhKeyPair) {
              e2eeNotice.innerHTML = '🔒 Messages are end-to-end encrypted';
            } else {
              e2eeNotice.innerHTML = '🔓 Messages are <b>not</b> encrypted — the other party does not support E2EE';
            }
            document.getElementById('messages').appendChild(e2eeNotice);
            if (msgs.length > 0) {
              const notice = document.createElement('div');
              notice.id = 'history-notice';
              notice.textContent = `── ${msgs.length} earlier messages ──`;
              document.getElementById('messages').appendChild(notice);
            }
            for (const m of msgs) {
              let histContent = m.content;
              let histEncrypted = !!m.encrypted;
              if (m.encrypted && m.nonce) {
                // Determine peer key: if from me, use partner's key; if from partner, use partner's key
                const peerKeyForDecrypt = getPeerEcdhPublic(m.from === myKey ? m.to : m.from) || getPeerEcdhPublic(msg.partner);
                if (peerKeyForDecrypt) {
                  const plain = await decryptDmContent(m.content, m.nonce, peerKeyForDecrypt);
                  histContent = plain !== null ? plain : '🔒 [Decryption failed]';
                } else {
                  histContent = '🔒 [Cannot decrypt — missing key]';
                }
              }
              addDmMessage(m.from_name || shortKey(m.from), histContent, m.timestamp, m.from, m.to, histEncrypted);
            }
          }
          break;
        }
        case 'link_previews': {
          // Render link previews under the matching message.
          if (msg.channel !== activeChannel) break;
          const msgEl = document.querySelector(`.message[data-from="${msg.from}"][data-timestamp="${msg.timestamp}"]`);
          if (msgEl && msg.previews && msg.previews.length > 0) {
            const bodyEl = msgEl.querySelector('.body');
            if (bodyEl) {
              for (const p of msg.previews.slice(0, 3)) {
                const card = document.createElement('div');
                card.className = 'link-preview';
                card.onclick = () => card.classList.toggle('collapsed');
                let html = '<div class="lp-text">';
                if (p.site_name) html += `<div class="lp-site">${esc(p.site_name)}</div>`;
                if (p.title) html += `<div class="lp-title"><a href="${esc(p.url)}" target="_blank" rel="noopener">${esc(p.title)}</a></div>`;
                if (p.description) html += `<div class="lp-desc">${esc(p.description)}</div>`;
                html += '</div>';
                if (p.image) html += `<img class="lp-thumb" src="${esc(p.image)}" alt="" loading="lazy" onerror="this.style.display='none'">`;
                card.innerHTML = html;
                bodyEl.after(card);
              }
            }
          }
          break;
        }
        case 'system':
          // Handle sync data responses (encoded as system messages with prefix).
          if (msg.message && msg.message.startsWith('__sync_data__:')) {
            const payload = msg.message.slice('__sync_data__:'.length);
            handleSyncData(payload);
            break;
          }
          if (msg.message === 'sync_ack') break; // Silent ack
          addSystemMessage(msg.message);
          break;
        case 'name_taken': {
          // Stop reconnecting — this is a permanent error, not a transient disconnect.
          clearTimeout(reconnectTimer);
          reconnectDelay = 1000;
          // Clear the saved name so auto-login doesn't loop.
          localStorage.removeItem('humanity_name');
          // Show login screen with error.
          document.getElementById('login-screen').style.display = 'flex';
          document.getElementById('chat-screen').style.display = 'none';
          const errEl = document.getElementById('login-error');
          errEl.textContent = msg.message;
          errEl.style.display = 'block';
          document.getElementById('crypto-status').textContent = '';
          identityConfirmed = false;
          if (ws) { ws.onclose = null; ws.close(); ws = null; }
          setStatus('disconnected', 'Choose a different name');
          break;
        }
      }
    }

    async function sendMessage() {
      const input = document.getElementById('msg-input');
      let content = input.value.trim();
      if (!content || !ws || ws.readyState !== WebSocket.OPEN) return;

      // Enforce character limit (on user's own text, before adding quote).
      const charLimit = getMaxMsgLength();
      if (content.length > charLimit) {
        addSystemMessage(`Message too long (${content.length}/${charLimit} chars). Please shorten it.`);
        return;
      }

      // Prepend full quote from reply bar if active (quotes don't count toward limit).
      if (replyTarget) {
        const quoteLines = replyTarget.body.split('\n').map(l => '> ' + l).join('\n');
        content = quoteLines + '\n' + content;
        clearReplyTarget();
      }

      const timestamp = Date.now();

      // Sign the full content (including quote) if Ed25519 is available.
      let signature = null;
      if (myIdentity && myIdentity.canSign) {
        signature = await signMessage(myIdentity.privateKey, content, timestamp);
      }

      const msg = {
        type: 'chat',
        from: myKey,
        from_name: myName,
        content: content,
        timestamp: timestamp,
        channel: activeChannel,
      };
      if (signature) {
        msg.signature = signature;
      }

      ws.send(JSON.stringify(msg));

      const key = myKey + ':' + timestamp;
      seenTimestamps.add(key);
      addChatMessage(myName, content, timestamp, myKey, false, !!signature);
      input.value = '';
      input.style.height = 'auto'; // Reset textarea height after sending.
      input.focus();
    }

    // ── Rendering ──
    function addChatMessage(author, body, timestamp, fromKey, isHistory, signed) {
      // Skip messages from blocked users entirely.
      if (author && isBlocked(author)) return;

      const el = document.createElement('div');
      el.className = 'message';
      el.dataset.from = fromKey;
      el.dataset.timestamp = timestamp;

      const time = formatTime(timestamp);
      const isMe = fromKey === myKey;
      const isBot = fromKey && fromKey.startsWith('bot_');

      let authorClass = '';
      if (isMe) {
        authorClass = ' you';
      } else if (isBot) {
        authorClass = ' bot';
      }

      const sigBadge = signed
        ? '<span class="sig-badge" title="Ed25519 signed">✓</span>'
        : '';

      // Action buttons: react, reply, edit (own), pin (admin/mod), delete (own).
      const myRole = (peerData[myKey] && peerData[myKey].role) ? peerData[myKey].role : '';
      const isStaff = myRole === 'admin' || myRole === 'mod';
      let actions = '<div class="msg-actions">';
      actions += '<button class="react-btn" title="React">😀</button>';
      actions += '<button class="reply-btn" title="Reply">↩</button>';
      if (isMe) {
        actions += '<button class="edit-btn" title="Edit">✏️</button>';
      }
      if (isStaff) {
        actions += '<button class="pin-btn" title="Pin (server)">📌</button>';
      }
      actions += '<button class="mypin-btn" title="Pin for me">⭐</button>';
      if (isMe) {
        actions += '<button class="delete-btn" title="Delete">✕</button>';
      }
      actions += '</div>';

      const isBotMsg = fromKey && fromKey.startsWith('bot_');
      const identiconSrc = (!isBotMsg && fromKey) ? generateIdenticon(fromKey, 20) : '';
      const identiconHtml = isBotMsg ? '<span class="identicon" style="font-size:18px;line-height:20px;">🤖</span>' : (identiconSrc ? `<img src="${identiconSrc}" class="identicon" alt="">` : '');

      // Look up role for author badge.
      const peerRole = (peerData[fromKey] && peerData[fromKey].role) ? peerData[fromKey].role : '';
      const badge = roleBadge(peerRole);

      // Check for todo-channel special rendering.
      let bodyHtml;
      const isTodoChannel = activeChannel === 'todo';
      const isHeronBot = fromKey && fromKey.startsWith('bot_') && (author === 'Heron 🪶' || author === 'Heron');
      if (isTodoChannel && isHeronBot) {
        const todoHtml = formatTodoMessage(body);
        bodyHtml = todoHtml || formatBody(body);
      } else {
        bodyHtml = formatBody(body);
      }

      el.innerHTML = `
        <div class="meta">
          ${identiconHtml}
          <span class="author${authorClass}" data-username="${esc(author)}" data-pubkey="${esc(fromKey)}" style="cursor:pointer;">${esc(author)}</span>${badge}
          ${sigBadge}
          <span class="time">${time}</span>
        </div>
        <div class="body">${bodyHtml}</div>
        <div class="reactions" data-from="${esc(fromKey)}" data-ts="${timestamp}"></div>
        ${actions}
      `;

      // Context menu on author name click.
      const authorEl = el.querySelector('.author');
      if (authorEl) {
        authorEl.addEventListener('click', (e) => {
          e.stopPropagation();
          showUserContextMenu(e, author, fromKey);
        });
      }

      // Click react button → show emoji picker.
      el.querySelector('.react-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        showReactionPicker(e.target, fromKey, timestamp, el);
      });

      // Click reply button → show reply preview bar above input.
      el.querySelector('.reply-btn').addEventListener('click', (e) => {
        e.stopPropagation();
        setReplyTarget(author, body, fromKey, timestamp, el);
        document.getElementById('msg-input').focus();
      });

      // Click edit button → inline edit mode.
      const editBtn = el.querySelector('.edit-btn');
      if (editBtn) {
        editBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          startEditMode(el, body, fromKey, timestamp);
        });
      }

      // Click pin button → server pin (admin/mod).
      const pinBtn = el.querySelector('.pin-btn');
      if (pinBtn) {
        pinBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          pinMessageFromUI(fromKey, author, body, timestamp);
        });
      }

      // Click ⭐ button → personal pin.
      const mypinBtn = el.querySelector('.mypin-btn');
      if (mypinBtn) {
        mypinBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          toggleMyPin(fromKey, author, body, timestamp);
        });
      }

      // Click delete button → send delete request.
      const delBtn = el.querySelector('.delete-btn');
      if (delBtn) {
        delBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify({ type: 'delete', from: myKey, timestamp: Number(timestamp) }));
            el.remove(); // Remove locally immediately.
          }
        });
      }

      appendMessage(el);
      if (window.twemoji) twemoji.parse(el);
    }

    function addSystemMessage(text) {
      // Route certain messages as ephemeral notices instead of permanent system messages.
      const lower = text.toLowerCase();
      // Link codes — ephemeral yellow, 5 minutes (matches server expiry)
      if (lower.includes('link code:')) {
        return addNotice(text, 'yellow', 300);
      }
      // Invite codes — ephemeral yellow, 24h display for 60s (code lasts 24h, notice fades)
      if (lower.includes('invite code:')) {
        return addNotice(text, 'yellow', 120);
      }
      // Rate limiting / slow mode — ephemeral cyan, 15s
      if (lower.includes('rate limit') || lower.includes('please wait') || lower.includes('slow mode')) {
        return addNotice(text, 'cyan', 15);
      }
      // Kick/ban/mute — important red, 30s
      if (lower.includes('kicked') || lower.includes('banned') || lower.includes('muted')) {
        return addNotice(text, 'red', 30);
      }
      // Lockdown — red, 30s
      if (lower.includes('lockdown')) {
        return addNotice(text, 'red', 30);
      }
      // Pin actions — green, 20s
      if (lower.includes('pinned a message')) {
        return addNotice(text, 'green', 20);
      }
      // Verified/donor — green, 20s
      if (lower.includes('verified') || lower.includes('donor')) {
        return addNotice(text, 'green', 20);
      }
      // Everything else — regular system message
      const el = document.createElement('div');
      el.className = 'message system';
      el.textContent = `• ${text}`;
      appendMessage(el);
    }

    function formatCountdown(secs) {
      if (secs >= 60) {
        const m = Math.floor(secs / 60);
        const s = secs % 60;
        return s > 0 ? `${m}m ${s}s` : `${m}m`;
      }
      return `${secs}s`;
    }

    /**
     * Add an ephemeral notice with countdown timer.
     * @param {string} text - Notice text
     * @param {string} color - red|yellow|green|blue|cyan|magenta
     * @param {number} seconds - Auto-dismiss after N seconds
     */
    function addNotice(text, color, seconds) {
      const el = document.createElement('div');
      el.className = `notice notice-${color}`;
      const textSpan = document.createElement('span');
      textSpan.className = 'notice-text';
      textSpan.textContent = text;
      const timerSpan = document.createElement('span');
      timerSpan.className = 'notice-timer';
      let remaining = seconds;
      timerSpan.textContent = formatCountdown(remaining);
      el.appendChild(textSpan);
      el.appendChild(timerSpan);
      appendMessage(el);

      const interval = setInterval(() => {
        remaining--;
        if (remaining <= 0) {
          clearInterval(interval);
          el.classList.add('fading');
          setTimeout(() => el.remove(), 500);
        } else {
          timerSpan.textContent = formatCountdown(remaining);
        }
      }, 1000);
    }

    function addDateSeparator(dateStr) {
      const el = document.createElement('div');
      el.className = 'date-separator';
      el.textContent = dateStr;
      document.getElementById('messages').appendChild(el);
    }

    function appendMessage(el) {
      const container = document.getElementById('messages');
      const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 100;
      container.appendChild(el);
      if (isNearBottom) {
        container.scrollTop = container.scrollHeight;
      }
    }

    let myUploadToken = '';
    function updatePeerList(peers) {
      // Update peerData from peer_list (online peers only — for backwards compat).
      for (const p of peers) {
        peerData[p.public_key] = p;
        // M-4: Capture our upload token.
        if (p.public_key === myKey && p.upload_token) {
          myUploadToken = p.upload_token;
        }
        // Track our role for UI rendering (federation admin buttons, etc.).
        if (p.public_key === myKey && p.role) {
          window.myPeerRole = p.role;
        }
      }
    }

    function updateUserList(users) {
      const list = document.getElementById('peer-list');

      // Update peerData from full user list.
      for (const u of users) {
        peerData[u.public_key] = { public_key: u.public_key, display_name: u.name, role: u.role || '', ecdh_public: u.ecdh_public || null };
      }

      const online = users.filter(u => u.online);
      const offline = users.filter(u => !u.online);

      function renderUser(u) {
        const isMe = u.name === myName;
        const isBot = u.public_key && u.public_key.startsWith('bot_');
        const icon = isBot ? '<span style="font-size:14px;vertical-align:middle;">🤖</span>' : (u.public_key ? `<img src="${generateIdenticon(u.public_key, 16)}" class="identicon" style="width:14px;height:14px;">` : '');
        const badge = isBot ? ' <img src="https://cdn.jsdelivr.net/npm/@twemoji/svg@latest/1fab6.svg" alt="🪶" style="width:12px;height:12px;vertical-align:middle;"> ' : roleBadge(u.role);
        const escapedName = esc(u.name);
        const escapedKey = esc(u.public_key);
        const deviceCount = (!isBot && u.key_count > 1) ? ` <span style="font-size:0.6rem;color:var(--text-muted)">(${u.key_count} devices)</span>` : '';
        const blocked = isBlocked(u.name);
        const blockIndicator = blocked ? ' <span class="block-indicator" title="Blocked" style="font-size:0.65rem;">🚫</span>' : '';
        const dimStyle = u.online ? (blocked ? ' style="opacity:0.5;text-decoration:line-through"' : '') : (blocked ? ' style="opacity:0.5;text-decoration:line-through"' : ' style="opacity:0.5"');
        const botClass = isBot ? ' is-bot' : '';
        return `<div class="peer${isMe ? ' is-you' : ''}${botClass}" data-username="${escapedName}" data-pubkey="${escapedKey}"${dimStyle}>
          ${icon} ${escapedName}${badge}${isMe ? ' (you)' : ''}${deviceCount}${blockIndicator}
        </div>`;
      }

      let html = '';
      html += `<div style="font-size:0.6rem;text-transform:uppercase;color:var(--text-muted);letter-spacing:0.08em;margin-bottom:0.3rem;">Online (${online.length})</div>`;
      html += online.map(renderUser).join('');
      if (offline.length > 0) {
        html += `<div style="height:1px;background:var(--border);margin:0.5rem 0;"></div>`;
        html += `<div style="font-size:0.6rem;text-transform:uppercase;color:var(--text-muted);letter-spacing:0.08em;margin-bottom:0.3rem;">Offline (${offline.length})</div>`;
        html += offline.map(renderUser).join('');
      }

      list.innerHTML = html;
      if (window.twemoji) twemoji.parse(list);
    }

    function updateChannelList(channels) {
      channelList = channels;
      renderChannelList();
    }

    function renderChannelList() {
      // Legacy hidden channel-list (kept for compatibility)
      const list = document.getElementById('channel-list');
      list.innerHTML = channelList.map(ch => {
        const isActive = ch.id === activeChannel && !activeDmPartner;
        const title = ch.description ? ` title="${esc(ch.description)}"` : '';
        const lock = ch.read_only ? ' 🔒' : '';
        return `<div class="channel-item${isActive ? ' active' : ''}"${title} onclick="switchChannel('${esc(ch.id)}')">${esc(ch.name)}${lock}</div>`;
      }).join('');
      if (window.twemoji) twemoji.parse(list);
      // Re-apply unread dots after re-rendering.
      if (typeof renderUnreadDots === 'function') renderUnreadDots();
      // Also update the server list in the Servers tab
      if (typeof renderServerList === 'function') renderServerList();
    }

    function switchChannel(channelId) {
      // Clear DM view if active.
      activeDmPartner = null;
      activeDmPartnerName = '';
      renderDmList();

      // Switch to Servers tab in sidebar.
      if (typeof switchSidebarTab === 'function') switchSidebarTab('servers', true);

      activeChannel = channelId;
      localStorage.setItem('humanity_channel', channelId);
      document.getElementById('messages').innerHTML = '';
      seenTimestamps.clear();
      // Clear local reaction state for old channel messages.
      Object.keys(messageReactions).forEach(k => delete messageReactions[k]);
      renderChannelList();
      updateChannelHeader();
      updateInputForChannel();
      // Load pins for the new channel.
      loadPinsForChannel(channelId);
      // Close pin list when switching channels.
      document.getElementById('pin-list').classList.remove('open');
      loadHistory().then(() => {
        // Load persisted reactions after messages are rendered.
        loadReactionsForChannel(channelId);
      });
    }

    function updateInputForChannel() {
      const ch = channelList.find(c => c.id === activeChannel);
      const input = document.getElementById('msg-input');
      const sendBtn = document.getElementById('send-btn');
      // Check if the current user is admin/mod.
      const myRole = (peerData[myKey] && peerData[myKey].role) ? peerData[myKey].role : '';
      const isStaff = myRole === 'admin' || myRole === 'mod';

      if (ch && ch.read_only && !isStaff) {
        input.disabled = true;
        input.placeholder = 'This channel is read-only';
        sendBtn.disabled = true;
      } else {
        input.disabled = false;
        input.placeholder = 'Type a message…';
        sendBtn.disabled = false;
      }
    }

    function updateChannelHeader() {
      const header = document.getElementById('channel-header');
      const ch = channelList.find(c => c.id === activeChannel);
      if (ch) {
        const lock = ch.read_only ? ' 🔒' : '';
        header.innerHTML = `<span class="ch-name"># ${esc(ch.name)}${lock}</span>${ch.description ? `<span class="ch-desc">— ${esc(ch.description)}</span>` : ''}`;
        header.style.display = 'block';
        if (window.twemoji) twemoji.parse(header);
      } else {
        header.style.display = 'none';
      }
    }

    async function updateStats() {
      try {
        const resp = await fetch('/api/stats');
        const data = await resp.json();
        document.getElementById('stats').textContent =
          `${data.total_messages} msgs · ${data.connected_peers} online`;
      } catch (e) { /* ignore */ }
    }

    // ── Utilities ──
    function setStatus(cls, text) {
      const el = document.getElementById('status');
      el.className = cls;
      document.getElementById('status-text').textContent = text;
    }

    function formatTime(ts) {
      const d = new Date(ts);
      const now = new Date();
      const time = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      if (d.toDateString() !== now.toDateString()) {
        return d.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + time;
      }
      return time;
    }

    function formatBody(text) {
      // Step 1: Extract code blocks BEFORE escaping (they get special treatment).
      const codeBlocks = [];
      const CODE_PLACEHOLDER = '\x00CB';
      let processedText = text.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
        codeBlocks.push({ lang: lang || '', code: code.replace(/\n$/, '') });
        return CODE_PLACEHOLDER + (codeBlocks.length - 1) + CODE_PLACEHOLDER;
      });

      // Step 2: Escape HTML for the non-code parts.
      let safe = esc(processedText);

      // Step 3: File URLs → inline players/file cards.
      // Audio files
      safe = safe.replace(
        /((?:https?:\/\/[^\s<]+|\/uploads\/[^\s<]+)\.(?:mp3|ogg|wav)(?:\?[^\s<]*)?)/gi,
        '<audio controls preload="none" src="$1"></audio>'
      );
      // Video files
      safe = safe.replace(
        /((?:https?:\/\/[^\s<]+|\/uploads\/[^\s<]+)\.(?:mp4|webm)(?:\?[^\s<]*)?)/gi,
        '<video controls preload="none" src="$1" style="max-height:300px;"></video>'
      );
      // Document/archive files → file cards
      safe = safe.replace(
        /((?:https?:\/\/[^\s<]+|\/uploads\/[^\s<]+)\.(pdf|txt|md|json|zip|tar\.gz|gz)(?:\?[^\s<]*)?)/gi,
        (match, url, ext) => {
          const icon = ['zip','tar.gz','gz'].includes(ext.toLowerCase()) ? '📦' :
                       ['mp3','ogg','wav'].includes(ext.toLowerCase()) ? '🎵' : '📄';
          const fname = url.split('/').pop().split('?')[0];
          return `<div class="file-card"><span class="file-icon">${icon}</span><div class="file-info"><div class="file-name">${esc(fname)}</div></div><a href="${url}" target="_blank" rel="noopener" class="file-download">Download</a></div>`;
        }
      );

      // Image URLs → collapsed image placeholders.
      safe = safe.replace(
        /((?:https?:\/\/[^\s<]+|\/uploads\/[^\s<]+)\.(?:png|jpe?g|gif|webp)(?:\?[^\s<]*)?)/gi,
        '<span class="img-placeholder" data-img-url="$1">🖼️ Image (click to load)</span>'
      );

      // Other URLs → clickable links.
      safe = safe.replace(
        /(?<!["=])(https?:\/\/[^\s<]+)(?![^<]*<\/a>|[^<]*<\/span>|[^<]*<\/audio>|[^<]*<\/video>)/g,
        '<a href="$1" target="_blank" rel="noopener" style="color:var(--accent)">$1</a>'
      );

      // Step 4: Markdown formatting.
      // __bold__ or **bold**
      safe = safe.replace(/__(.+?)__/g, '<strong>$1</strong>');
      safe = safe.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
      // *italic* or _italic_ (single, not inside words)
      safe = safe.replace(/\*(.+?)\*/g, '<em>$1</em>');
      // ~~strikethrough~~
      safe = safe.replace(/~~(.+?)~~/g, '<del>$1</del>');
      // `inline code` (but not inside code blocks)
      safe = safe.replace(/`([^`\n]+)`/g, '<code>$1</code>');

      // @mentions — highlight usernames.
      safe = safe.replace(/@([A-Za-z0-9_-]+)/g, (match, name) => {
        const isMe = myName && name.toLowerCase() === myName.toLowerCase();
        const cls = isMe ? 'mention mention-me' : 'mention';
        return `<span class="${cls}">@${esc(name)}</span>`;
      });

      // Step 5: Process line-level formatting (quotes, lists).
      const lines = safe.split('\n');
      let result = [];
      let quoteLines = [];
      let listItems = [];

      function flushQuote() {
        if (quoteLines.length > 0) {
          const full = quoteLines.join('<br>');
          const plainLen = quoteLines.join(' ').length;
          if (plainLen > 120 || quoteLines.length > 2) {
            const previewText = quoteLines[0].substring(0, 80) + (plainLen > 80 ? '…' : '');
            result.push(
              '<div class="quote-block" onclick="this.classList.toggle(\'expanded\')">' +
                '<span class="quote-preview">' + previewText +
                  '<span class="quote-expand">▸ show more</span>' +
                '</span>' +
                '<span class="quote-full">' + full +
                  '<br><span class="quote-expand">▴ show less</span>' +
                '</span>' +
              '</div>'
            );
          } else {
            result.push('<div class="quote-block">' + full + '</div>');
          }
          quoteLines = [];
        }
      }

      function flushList() {
        if (listItems.length > 0) {
          result.push('<ul class="md-list">' + listItems.map(li => '<li>' + li + '</li>').join('') + '</ul>');
          listItems = [];
        }
      }

      for (const line of lines) {
        if (line.startsWith('&gt; ')) {
          flushList();
          quoteLines.push(line.substring(5));
        } else if (/^[-*] /.test(line)) {
          flushQuote();
          listItems.push(line.substring(2));
        } else {
          flushQuote();
          flushList();
          result.push(line);
        }
      }
      flushQuote();
      flushList();

      safe = result.join('\n');

      // Step 6: Restore code blocks with styled rendering.
      safe = safe.replace(new RegExp(CODE_PLACEHOLDER.replace(/\0/g, '\\0') + '(\\d+)' + CODE_PLACEHOLDER.replace(/\0/g, '\\0'), 'g'), (match, idx) => {
        const block = codeBlocks[parseInt(idx)];
        if (!block) return match;
        const escapedCode = esc(block.code);
        const langLabel = block.lang ? `<span class="code-lang">${esc(block.lang)}</span>` : '';
        return `<div class="code-block-wrapper">${langLabel}<button class="code-copy" onclick="navigator.clipboard.writeText(this.parentElement.querySelector('code').textContent);this.textContent='✓ Copied';setTimeout(()=>this.textContent='📋 Copy',1500)">📋 Copy</button><pre><code>${escapedCode}</code></pre></div>`;
      });

      return safe;
    }

    /**
     * Format todo-channel messages from Heron bot.
     * Detects [ACTIVE], [COMPLETED], [INACTIVE] section markers and renders
     * them as collapsible <details> elements with color-coded backgrounds.
     */
    function formatTodoMessage(text) {
      const sectionRegex = /\[(ACTIVE|COMPLETED|INACTIVE)\]/g;
      const parts = [];
      let lastIndex = 0;
      let match;
      const matches = [];

      while ((match = sectionRegex.exec(text)) !== null) {
        matches.push({ type: match[1], index: match.index, end: match.index + match[0].length });
      }

      if (matches.length === 0) return null; // Not a todo message

      // Text before first section
      const preamble = text.substring(0, matches[0].index).trim();
      if (preamble) {
        parts.push('<div style="margin-bottom:0.4rem;">' + esc(preamble) + '</div>');
      }

      for (let i = 0; i < matches.length; i++) {
        const m = matches[i];
        const nextStart = (i + 1 < matches.length) ? matches[i + 1].index : text.length;
        const sectionContent = text.substring(m.end, nextStart).trim();
        const cssClass = 'todo-' + m.type.toLowerCase();
        const label = m.type.charAt(0) + m.type.slice(1).toLowerCase();
        const icon = m.type === 'ACTIVE' ? '🔵' : m.type === 'COMPLETED' ? '✅' : '🔴';
        parts.push(
          '<details class="todo-section ' + cssClass + '" open>' +
            '<summary>' + icon + ' ' + esc(label) + '</summary>' +
            '<div class="todo-items">' + esc(sectionContent) + '</div>' +
          '</details>'
        );
      }

      return parts.join('');
    }

    function shortKey(hex) {
      if (!hex) return '???';
      return hex.substring(0, 8) + '…';
    }

    function esc(str) {
      const d = document.createElement('div');
      d.textContent = str || '';
      return d.innerHTML.replace(/'/g, '&#39;').replace(/"/g, '&quot;');
    }

    // ── Identicon Generator ──
    // Creates a 5x5 symmetric pixel art from a hex key string.
    // WHY: Visual identity at a glance, unique per key, no upload needed.
    const identiconCache = {};
    function generateIdenticon(hexKey, size) {
      size = size || 24;
      const cacheKey = hexKey + ':' + size;
      if (identiconCache[cacheKey]) return identiconCache[cacheKey];

      const canvas = document.createElement('canvas');
      canvas.width = size;
      canvas.height = size;
      const ctx = canvas.getContext('2d');

      // Parse first 15 bytes from hex for the 5x5 grid (only need half — mirror for symmetry).
      const bytes = [];
      for (let i = 0; i < 30 && i < hexKey.length; i += 2) {
        bytes.push(parseInt(hexKey.substr(i, 2), 16) || 0);
      }

      // Color from bytes 0-2 (ensure visible on dark bg by keeping values 80-220).
      const r = 80 + (bytes[0] % 140);
      const g = 80 + (bytes[1] % 140);
      const b = 80 + (bytes[2] % 140);
      const color = `rgb(${r},${g},${b})`;
      const bg = '#1a1a1a';

      const cellSize = size / 5;
      ctx.fillStyle = bg;
      ctx.fillRect(0, 0, size, size);
      ctx.fillStyle = color;

      // 5x5 grid, horizontally symmetric (columns 0-2 mirror to 4-2).
      for (let row = 0; row < 5; row++) {
        for (let col = 0; col < 3; col++) {
          const byteIdx = 3 + row * 3 + col;
          if (byteIdx < bytes.length && bytes[byteIdx] % 2 === 0) {
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
            // Mirror: column 4-col.
            if (col < 2) {
              ctx.fillRect((4 - col) * cellSize, row * cellSize, cellSize, cellSize);
            }
          }
        }
      }

      const dataUrl = canvas.toDataURL();
      identiconCache[cacheKey] = dataUrl;
      return dataUrl;
    }

    // ── Emoji Reactions ──
    const REACTION_EMOJIS = ['👍', '❤️', '😂', '😮', '😢', '🎉', '🔥', '👀'];
    // Track reactions: key = "fromKey:timestamp", value = { emoji: Set(reactorKeys) }
    const messageReactions = {};

    function showReactionPicker(btn, targetFrom, targetTs, msgEl) {
      // Close any existing picker.
      document.querySelectorAll('.reaction-picker').forEach(p => p.remove());

      const picker = document.createElement('div');
      picker.className = 'reaction-picker';
      picker.style.cssText = 'position:absolute;top:-2rem;right:0;background:var(--bg-secondary);border:1px solid var(--border);border-radius:6px;padding:0.2rem;display:flex;gap:0.15rem;z-index:20;';
      REACTION_EMOJIS.forEach(emoji => {
        const btn = document.createElement('span');
        btn.textContent = emoji;
        btn.style.cssText = 'cursor:pointer;padding:0.15rem 0.25rem;border-radius:3px;font-size:0.9rem;';
        btn.onmouseover = () => btn.style.background = 'var(--bg-hover)';
        btn.onmouseout = () => btn.style.background = '';
        btn.onclick = (e) => {
          e.stopPropagation();
          sendReaction(targetFrom, targetTs, emoji);
          picker.remove();
        };
        picker.appendChild(btn);
      });
      if (window.twemoji) twemoji.parse(picker);

      msgEl.style.position = 'relative';
      msgEl.appendChild(picker);
      // Close picker when clicking elsewhere.
      setTimeout(() => {
        document.addEventListener('click', function closePicker() {
          picker.remove();
          document.removeEventListener('click', closePicker);
        }, { once: true });
      }, 0);
    }

    function sendReaction(targetFrom, targetTs, emoji) {
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      ws.send(JSON.stringify({
        type: 'reaction',
        target_from: targetFrom,
        target_timestamp: Number(targetTs),
        emoji: emoji,
        from: myKey,
        from_name: myName,
        channel: activeChannel,
      }));
      // Apply locally immediately.
      applyReaction(targetFrom, Number(targetTs), emoji, myKey, myName);
    }

    function applyReaction(targetFrom, targetTs, emoji, reactorKey, reactorName) {
      const rKey = targetFrom + ':' + targetTs;
      if (!messageReactions[rKey]) messageReactions[rKey] = {};
      if (!messageReactions[rKey][emoji]) messageReactions[rKey][emoji] = new Set();

      const set = messageReactions[rKey][emoji];
      if (set.has(reactorKey)) {
        set.delete(reactorKey); // Toggle off.
        if (set.size === 0) delete messageReactions[rKey][emoji];
      } else {
        set.add(reactorKey); // Toggle on.
      }
      renderReactions(targetFrom, targetTs);
    }

    function renderReactions(targetFrom, targetTs) {
      const rKey = targetFrom + ':' + targetTs;
      const reactions = messageReactions[rKey] || {};
      // Find the reactions div in the DOM.
      const msgEl = document.querySelector(`.reactions[data-from="${targetFrom}"][data-ts="${targetTs}"]`);
      if (!msgEl) return;

      msgEl.innerHTML = Object.entries(reactions).map(([emoji, users]) => {
        const isMine = users.has(myKey);
        return `<span class="reaction-badge${isMine ? ' mine' : ''}" data-target-from="${esc(targetFrom)}" data-target-ts="${targetTs}" data-emoji="${esc(emoji)}">${esc(emoji)} <span class="count">${users.size}</span></span>`;
      }).join('');
      if (window.twemoji) twemoji.parse(msgEl);
    }

    // Apply a reaction from sync (add-only, no toggle).
    function applyReactionSync(targetFrom, targetTs, emoji, reactorKey) {
      const rKey = targetFrom + ':' + targetTs;
      if (!messageReactions[rKey]) messageReactions[rKey] = {};
      if (!messageReactions[rKey][emoji]) messageReactions[rKey][emoji] = new Set();
      messageReactions[rKey][emoji].add(reactorKey);
      renderReactions(targetFrom, targetTs);
    }

    // Load reactions from the API for the current channel and apply them.
    async function loadReactionsForChannel(channelId) {
      try {
        const resp = await fetch(`/api/reactions?channel=${encodeURIComponent(channelId)}&limit=500`);
        const data = await resp.json();
        if (data.reactions && data.reactions.length > 0) {
          for (const r of data.reactions) {
            applyReactionSync(r.target_from, r.target_timestamp, r.emoji, r.reactor_key);
          }
        }
      } catch (e) {
        console.warn('Failed to load reactions:', e);
      }
    }

    // ── Message Editing ──
    function startEditMode(msgEl, originalBody, fromKey, timestamp) {
      const bodyEl = msgEl.querySelector('.body');
      if (!bodyEl || msgEl.querySelector('.edit-area')) return; // Already editing.

      // Strip quote lines from the original body for editing (quotes are read-only context).
      const lines = originalBody.split('\n');
      const editableLines = [];
      let pastQuotes = false;
      for (const line of lines) {
        if (!pastQuotes && line.startsWith('> ')) continue;
        pastQuotes = true;
        editableLines.push(line);
      }
      const editableText = editableLines.join('\n').trim() || originalBody;

      const savedHtml = bodyEl.innerHTML;
      bodyEl.innerHTML = '';

      const editArea = document.createElement('div');
      editArea.className = 'edit-area';

      const textarea = document.createElement('textarea');
      textarea.value = editableText;
      textarea.rows = Math.min(5, editableText.split('\n').length + 1);

      const buttons = document.createElement('div');
      buttons.className = 'edit-buttons';

      const saveBtn = document.createElement('button');
      saveBtn.className = 'edit-save';
      saveBtn.textContent = 'Save';
      saveBtn.onclick = (e) => {
        e.stopPropagation();
        const newContent = textarea.value.trim();
        if (!newContent || newContent.length > getMaxMsgLength()) return;
        // Send edit via WebSocket.
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'edit',
            from: myKey,
            timestamp: Number(timestamp),
            new_content: newContent,
            channel: activeChannel,
          }));
        }
        // Apply locally immediately.
        bodyEl.innerHTML = formatBody(newContent);
        if (!bodyEl.querySelector('.edited-marker')) {
          const marker = document.createElement('span');
          marker.className = 'edited-marker';
          marker.textContent = '(edited)';
          bodyEl.appendChild(marker);
        }
        if (window.twemoji) twemoji.parse(bodyEl);
      };

      const cancelBtn = document.createElement('button');
      cancelBtn.className = 'edit-cancel';
      cancelBtn.textContent = 'Cancel';
      cancelBtn.onclick = (e) => {
        e.stopPropagation();
        bodyEl.innerHTML = savedHtml;
        if (window.twemoji) twemoji.parse(bodyEl);
      };

      // Escape to cancel, Ctrl+Enter to save.
      textarea.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') { cancelBtn.click(); }
        if (e.key === 'Enter' && (e.ctrlKey || e.metaKey)) { saveBtn.click(); }
      });

      buttons.appendChild(cancelBtn);
      buttons.appendChild(saveBtn);
      editArea.appendChild(textarea);
      editArea.appendChild(buttons);
      bodyEl.appendChild(editArea);
      textarea.focus();
      textarea.setSelectionRange(textarea.value.length, textarea.value.length);
    }

    function applyEditToDOM(fromKey, timestamp, newContent) {
      const msgEl = document.querySelector(`.message[data-from="${fromKey}"][data-timestamp="${timestamp}"]`);
      if (!msgEl) return;
      const bodyEl = msgEl.querySelector('.body');
      if (!bodyEl) return;
      bodyEl.innerHTML = formatBody(newContent);
      // Add (edited) marker if not present.
      if (!bodyEl.querySelector('.edited-marker')) {
        const marker = document.createElement('span');
        marker.className = 'edited-marker';
        marker.textContent = '(edited)';
        bodyEl.appendChild(marker);
      }
      if (window.twemoji) twemoji.parse(bodyEl);
    }

    // ── Pin System ──
    let currentPins = []; // Array of pin objects for the active channel.

    function togglePinList() {
      const list = document.getElementById('pin-list');
      list.classList.toggle('open');
    }

    function renderPinBar() {
      const bar = document.getElementById('pin-bar');
      const countEl = document.getElementById('pin-count');
      const serverSection = document.getElementById('server-pins-section');
      const serverContainer = document.getElementById('server-pins');
      const mySection = document.getElementById('my-pins-section');
      const myContainer = document.getElementById('my-pins');
      const myPins = getMyPins();
      const total = currentPins.length + myPins.length;

      if (total === 0) {
        bar.style.display = 'none';
        document.getElementById('pin-list').classList.remove('open');
        serverSection.style.display = 'none';
        mySection.style.display = 'none';
        return;
      }

      bar.style.display = 'block';
      countEl.textContent = total;

      // Determine if user is admin/mod for showing server unpin buttons.
      const myRole = (peerData[myKey] && peerData[myKey].role) ? peerData[myKey].role : '';
      const isStaff = myRole === 'admin' || myRole === 'mod';

      // Server pins.
      if (currentPins.length > 0) {
        serverSection.style.display = 'block';
        let html = '';
        currentPins.forEach((pin, i) => {
          const time = formatTime(pin.original_timestamp);
          const unpinBtn = isStaff
            ? `<button class="pin-unpin" onclick="event.stopPropagation();unpinServer(${i + 1})" title="Unpin">✕</button>`
            : '';
          html += `<div class="pin-card" onclick="this.classList.toggle('expanded')">${unpinBtn}
            <div class="pin-card-author">${esc(pin.from_name)}</div>
            <div class="pin-card-body">${esc(pin.content)}</div>
            <div class="pin-expand-hint"><span class="hint-expand">▸ Click to expand</span><span class="hint-collapse">▴ Click to collapse</span></div>
            <div class="pin-card-meta">Pinned by ${esc(pin.pinned_by)} · ${time}</div>
          </div>`;
        });
        serverContainer.innerHTML = html;
      } else {
        serverSection.style.display = 'none';
        serverContainer.innerHTML = '';
      }

      // Personal pins.
      if (myPins.length > 0) {
        mySection.style.display = 'block';
        let html = '';
        myPins.forEach((pin, i) => {
          const time = formatTime(pin.original_timestamp);
          html += `<div class="pin-card" onclick="this.classList.toggle('expanded')"><button class="pin-unpin" onclick="event.stopPropagation();removeMyPin(${i})" title="Remove">✕</button>
            <div class="pin-card-author">${esc(pin.from_name)}</div>
            <div class="pin-card-body">${esc(pin.content)}</div>
            <div class="pin-expand-hint"><span class="hint-expand">▸ Click to expand</span><span class="hint-collapse">▴ Click to collapse</span></div>
            <div class="pin-card-meta">${time}</div>
          </div>`;
        });
        myContainer.innerHTML = html;
      } else {
        mySection.style.display = 'none';
        myContainer.innerHTML = '';
      }

      if (window.twemoji) { twemoji.parse(bar); twemoji.parse(serverContainer); twemoji.parse(myContainer); }
    }

    function unpinServer(index) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'chat', from: myKey, from_name: myName, content: '/unpin ' + index, timestamp: Date.now(), channel: activeChannel }));
      }
    }

    function removeMyPin(index) {
      let pins = getMyPins();
      pins.splice(index, 1);
      setMyPins(pins);
      renderPinBar();
    }

    async function loadPinsForChannel(channelId) {
      try {
        const resp = await fetch(`/api/pins?channel=${encodeURIComponent(channelId)}`);
        const data = await resp.json();
        currentPins = data.pins || [];
        renderPinBar();
      } catch (e) {
        console.warn('Failed to load pins:', e);
        currentPins = [];
        renderPinBar();
      }
    }

    function pinMessageFromUI(fromKey, fromName, content, timestamp) {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
          type: 'pin_request',
          from_key: fromKey,
          from_name: fromName,
          content: content,
          timestamp: Number(timestamp),
          channel: activeChannel,
        }));
      }
    }

    // ── Personal Pins (client-side, localStorage) ──
    function getMyPins() {
      try { return JSON.parse(localStorage.getItem('my_pins_' + activeChannel) || '[]'); }
      catch { return []; }
    }
    function setMyPins(pins) {
      localStorage.setItem('my_pins_' + activeChannel, JSON.stringify(pins));
    }
    function toggleMyPin(fromKey, fromName, content, timestamp) {
      let pins = getMyPins();
      const idx = pins.findIndex(p => p.from_key === fromKey && p.original_timestamp === Number(timestamp));
      if (idx >= 0) {
        pins.splice(idx, 1);
      } else {
        pins.push({ from_key: fromKey, from_name: fromName, content: content, original_timestamp: Number(timestamp), pinned_at: Date.now() });
      }
      setMyPins(pins);
      renderPinBar();
    }

    // ── Typing Indicator ──
    let typingTimers = {};   // key → timeout id
    let typingNames = {};    // key → display name
    let lastTypingSent = 0;  // throttle outbound typing events

    function showTypingIndicator(name) {
      // Suppress typing indicators from blocked users.
      if (isBlocked(name)) return;
      // Track who is typing, clear after 3 seconds of no updates.
      const key = name;
      typingNames[key] = name;
      clearTimeout(typingTimers[key]);
      typingTimers[key] = setTimeout(() => {
        delete typingNames[key];
        delete typingTimers[key];
        renderTypingIndicator();
      }, 3000);
      renderTypingIndicator();
    }

    function renderTypingIndicator() {
      const el = document.getElementById('typing-indicator');
      const names = Object.values(typingNames);
      if (names.length === 0) {
        el.textContent = '';
      } else if (names.length === 1) {
        el.textContent = names[0] + ' is typing…';
      } else if (names.length === 2) {
        el.textContent = names[0] + ' and ' + names[1] + ' are typing…';
      } else {
        el.textContent = 'Several people are typing…';
      }
    }

    // ── Image handling ──
    function loadImage(placeholder, url) {
      // Replace placeholder with loaded image. Click image to collapse, right-click/long-press for full size.
      const img = document.createElement('img');
      img.className = 'img-loaded';
      img.src = url;
      img.alt = 'Image';
      img.title = 'Click to collapse · Right-click to open full size';
      img.onclick = (e) => {
        e.preventDefault();
        // Collapse back to placeholder.
        const newPlaceholder = document.createElement('span');
        newPlaceholder.className = 'img-placeholder';
        newPlaceholder.textContent = '🖼️ Image (click to load)';
        newPlaceholder.onclick = () => loadImage(newPlaceholder, url);
        img.replaceWith(newPlaceholder);
        if (window.twemoji) twemoji.parse(newPlaceholder);
      };
      // Middle-click or Ctrl+click opens in new tab.
      img.onauxclick = (e) => { if (e.button === 1) window.open(url, '_blank'); };
      placeholder.replaceWith(img);
    }

    async function uploadImage(file) {
      const indicator = document.getElementById('upload-indicator');
      indicator.textContent = `Uploading ${file.name}…`;
      indicator.style.display = 'block';

      try {
        const formData = new FormData();
        formData.append('file', file);

        const uploadUrl = myUploadToken ? `/api/upload?token=${encodeURIComponent(myUploadToken)}` : (myKey ? `/api/upload?key=${encodeURIComponent(myKey)}` : '/api/upload');
        const resp = await fetch(uploadUrl, { method: 'POST', body: formData });
        if (!resp.ok) {
          const text = await resp.text();
          addSystemMessage(`Upload failed: ${text}`);
          return null;
        }

        const data = await resp.json();
        return data.url;
      } catch (e) {
        addSystemMessage(`Upload failed: ${e.message}`);
        return null;
      } finally {
        indicator.style.display = 'none';
      }
    }

    // Handle file attachment (📎 button).
    async function handleFileAttachment(event) {
      const file = event.target.files[0];
      if (!file) return;
      event.target.value = ''; // Reset for re-selection

      const url = await uploadImage(file); // Reuse existing upload function
      if (url && ws && ws.readyState === WebSocket.OPEN) {
        const timestamp = Date.now();
        const content = url;
        let signature = null;
        if (myIdentity && myIdentity.canSign) {
          signature = await signMessage(myIdentity.privateKey, content, timestamp);
        }
        const msg = { type: 'chat', from: myKey, from_name: myName, content, timestamp, channel: activeChannel };
        if (signature) msg.signature = signature;
        ws.send(JSON.stringify(msg));
        const key = myKey + ':' + timestamp;
        seenTimestamps.add(key);
        addChatMessage(myName, content, timestamp, myKey, false, !!signature);
      }
    }

    // Paste image from clipboard → upload and send.
    document.getElementById('msg-input').addEventListener('paste', async (e) => {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const file = item.getAsFile();
          if (!file) return;

          const url = await uploadImage(file);
          if (url && ws && ws.readyState === WebSocket.OPEN) {
            const timestamp = Date.now();
            const content = url;
            let signature = null;
            if (myIdentity && myIdentity.canSign) {
              signature = await signMessage(myIdentity.privateKey, content, timestamp);
            }
            const msg = { type: 'chat', from: myKey, from_name: myName, content, timestamp };
            if (signature) msg.signature = signature;
            ws.send(JSON.stringify(msg));
            const key = myKey + ':' + timestamp;
            seenTimestamps.add(key);
            addChatMessage(myName, content, timestamp, myKey, false, !!signature);
          }
          return;
        }
      }
    });

    // Drag and drop image → upload and send.
    const chatArea = document.getElementById('chat-area');
    chatArea.addEventListener('dragover', (e) => { e.preventDefault(); e.dataTransfer.dropEffect = 'copy'; });
    chatArea.addEventListener('drop', async (e) => {
      e.preventDefault();
      const files = e.dataTransfer?.files;
      if (!files) return;

      for (const file of files) {
        if (file.type.startsWith('image/')) {
          const url = await uploadImage(file);
          if (url && ws && ws.readyState === WebSocket.OPEN) {
            const timestamp = Date.now();
            const content = url;
            let signature = null;
            if (myIdentity && myIdentity.canSign) {
              signature = await signMessage(myIdentity.privateKey, content, timestamp);
            }
            const msg = { type: 'chat', from: myKey, from_name: myName, content, timestamp };
            if (signature) msg.signature = signature;
            ws.send(JSON.stringify(msg));
            const key = myKey + ':' + timestamp;
            seenTimestamps.add(key);
            addChatMessage(myName, content, timestamp, myKey, false, !!signature);
          }
        }
      }
    });

    function sendTypingIndicator() {
      // Throttle: send at most once every 2 seconds.
      const now = Date.now();
      if (now - lastTypingSent < 2000) return;
      if (!ws || ws.readyState !== WebSocket.OPEN) return;
      lastTypingSent = now;
      ws.send(JSON.stringify({ type: 'typing', from: myKey, from_name: myName }));
    }

    // ── Key Bindings ──
    document.getElementById('name-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter') connect();
    });

    // Enter to send is handled on #msg-input directly (see below).

    // ── Notifications ──
    let windowFocused = document.hasFocus();
    let unreadCount = 0;
    const originalTitle = document.title;
    let titleFlashInterval = null;

    function startTitleFlash() {
      if (titleFlashInterval) return;
      titleFlashInterval = setInterval(() => {
        document.title = document.title === originalTitle
          ? `(${unreadCount}) New Messages`
          : originalTitle;
      }, 2000);
    }

    function stopTitleFlash() {
      if (titleFlashInterval) {
        clearInterval(titleFlashInterval);
        titleFlashInterval = null;
      }
      document.title = originalTitle;
    }

    window.addEventListener('focus', () => {
      windowFocused = true;
      unreadCount = 0;
      stopTitleFlash();
    });

    window.addEventListener('blur', () => {
      windowFocused = false;
    });

    document.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        windowFocused = true;
        unreadCount = 0;
        stopTitleFlash();
      } else {
        windowFocused = false;
      }
    });

    /** Check if a message content mentions the current user. */
    function isMentioned(content) {
      if (!myName) return false;
      const pattern = new RegExp('@' + myName.replace(/[-_]/g, '[-_]'), 'i');
      return pattern.test(content);
    }

    // ── Notification Sounds ──
    let audioCtx = null;
    let soundEnabled = localStorage.getItem('humanity_sound_enabled') !== 'false';
    let selectedSound = localStorage.getItem('humanity_sound') || 'chime';

    const SOUND_PRESETS = {
      chime:  { label: 'Chime',  freqs: [[523.25, 0], [659.25, 0.12]], type: 'sine', vol: 0.15, decay: 0.6 },
      ping:   { label: 'Ping',   freqs: [[880, 0]], type: 'sine', vol: 0.12, decay: 0.3 },
      bell:   { label: 'Bell',   freqs: [[1046.5, 0], [784, 0.08]], type: 'sine', vol: 0.1, decay: 0.8 },
      pop:    { label: 'Pop',    freqs: [[600, 0]], type: 'triangle', vol: 0.2, decay: 0.15 },
      drop:   { label: 'Drop',   freqs: [[800, 0], [400, 0.08]], type: 'sine', vol: 0.12, decay: 0.4 },
      blip:   { label: 'Blip',   freqs: [[1200, 0], [900, 0.06]], type: 'square', vol: 0.06, decay: 0.15 },
    };

    function playNotificationChime() {
      if (!soundEnabled) return;
      try {
        if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const now = audioCtx.currentTime;
        const preset = SOUND_PRESETS[selectedSound] || SOUND_PRESETS.chime;
        preset.freqs.forEach(([freq, offset]) => {
          const osc = audioCtx.createOscillator();
          const gain = audioCtx.createGain();
          osc.type = preset.type;
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(preset.vol, now + offset);
          gain.gain.exponentialRampToValueAtTime(0.001, now + offset + preset.decay);
          osc.connect(gain);
          gain.connect(audioCtx.destination);
          osc.start(now + offset);
          osc.stop(now + offset + preset.decay);
        });
      } catch (e) { /* Audio not available */ }
    }

    function toggleSoundMenu() {
      const menu = document.getElementById('sound-menu');
      if (menu.style.display === 'none') {
        renderSoundOptions();
        menu.style.display = 'block';
        // Close on outside click.
        setTimeout(() => document.addEventListener('click', closeSoundMenuOutside), 0);
      } else {
        menu.style.display = 'none';
      }
    }
    function closeSoundMenuOutside(e) {
      const menu = document.getElementById('sound-menu');
      if (!menu.contains(e.target) && e.target.id !== 'sound-toggle') {
        menu.style.display = 'none';
        document.removeEventListener('click', closeSoundMenuOutside);
      }
    }
    function renderSoundOptions() {
      const container = document.getElementById('sound-options');
      container.innerHTML = Object.entries(SOUND_PRESETS).map(([key, preset]) => {
        const checked = key === selectedSound ? 'checked' : '';
        return `<label style="font-size:0.8rem;color:var(--text);display:flex;align-items:center;gap:0.4rem;cursor:pointer;padding:0.15rem 0;">
          <input type="radio" name="sound-choice" value="${key}" ${checked} onchange="selectSound('${key}')" style="accent-color:var(--accent);">
          ${esc(preset.label)}
          <button onclick="event.preventDefault();previewSound('${key}')" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:0.7rem;padding:0 0.3rem;">▶</button>
        </label>`;
      }).join('');
      document.getElementById('sound-enabled').checked = soundEnabled;
    }
    function selectSound(key) {
      selectedSound = key;
      localStorage.setItem('humanity_sound', key);
      playNotificationChime();
    }
    function previewSound(key) {
      const prev = selectedSound;
      selectedSound = key;
      playNotificationChime();
      selectedSound = prev;
    }
    function toggleSoundEnabled() {
      soundEnabled = document.getElementById('sound-enabled').checked;
      localStorage.setItem('humanity_sound_enabled', soundEnabled);
      // Update bell icon.
      document.getElementById('sound-toggle').textContent = soundEnabled ? '🔔' : '🔕';
    }
    // Set initial bell icon.
    document.getElementById('sound-toggle').textContent = soundEnabled ? '🔔' : '🔕';

    function notifyNewMessage(author, content, isDm) {
      const mentioned = isMentioned(content);

      if (!windowFocused) {
        unreadCount++;
        startTitleFlash();
      }

      // Always notify on @mention or DM, even if focused.
      if (mentioned || isDm || !windowFocused) {
        playNotificationChime();
      }

      // Browser notification (if permitted).
      if (Notification.permission === 'granted' && (!windowFocused || mentioned || isDm)) {
        const prefix = isDm ? '💬 DM from ' : '';
        const n = new Notification(prefix + author, {
          body: content.substring(0, 100),
          icon: '/favicon.png',
          tag: isDm ? 'humanity-dm' : 'humanity-msg',
        });
        n.onclick = () => {
          window.focus();
          n.close();
        };
      }
    }

    // Request notification permission (once, stored in localStorage).
    function requestNotifications() {
      if ('Notification' in window && Notification.permission === 'default') {
        if (!localStorage.getItem('humanity_notif_asked')) {
          Notification.requestPermission();
          localStorage.setItem('humanity_notif_asked', '1');
        }
      }
    }

    // Hook into message rendering to trigger notifications and update last-seen.
    const _origHandleMessage = handleMessage;
    handleMessage = function(msg) {
      _origHandleMessage(msg);
      if (msg.type === 'chat') {
        // Update last-seen timestamp.
        localStorage.setItem('humanity_last_seen', String(msg.timestamp));
        // Notify if from someone else.
        if (msg.from !== myKey) {
          notifyNewMessage(msg.from_name || 'Someone', msg.content, false);
        }
      }
    };

    // ── Auto-resize textarea to fit content ──
    function autoResizeTextarea(el) {
      el.style.height = 'auto';
      el.style.height = Math.min(el.scrollHeight, 150) + 'px';
    }

    // ── Enter to send + Shift+Enter for newline + typing indicator ──
    document.getElementById('msg-input').addEventListener('keydown', (e) => {
      if (e.key === 'Enter' && !e.shiftKey) {
        e.preventDefault();
        sendMessage();
      } else {
        // Any other key → send typing indicator (throttled).
        sendTypingIndicator();
      }
    });

    // Auto-resize + character counter on input.
    function getMaxMsgLength() {
      const myRole = (peerData[myKey] && peerData[myKey].role) ? peerData[myKey].role : '';
      return myRole === 'admin' ? 10000 : 2000;
    }
    const MAX_MSG_LENGTH = 2000; // default, updated dynamically
    document.getElementById('msg-input').addEventListener('input', (e) => {
      autoResizeTextarea(e.target);
      updateCharCounter(e.target.value.length);
    });

    function updateCharCounter(len) {
      const counter = document.getElementById('char-counter');
      const limit = getMaxMsgLength();
      // Show counter when within 200 chars of limit.
      if (len > limit - 200) {
        counter.style.display = 'block';
        counter.textContent = `${len} / ${limit}`;
        counter.className = len > limit ? 'over' : len > limit - 100 ? 'warn' : '';
      } else {
        counter.style.display = 'none';
      }
    }

    // ── Crypto status check ──
    (async () => {
      const has = await supportsEd25519();
      const el = document.getElementById('crypto-status');
      if (has) {
        el.textContent = '✓ Ed25519 signatures enabled — messages will be cryptographically signed';
        el.style.color = 'var(--success)';
      } else {
        el.textContent = '⚠ Ed25519 not supported in this browser — messages will not be signed';
        el.style.color = 'var(--warning)';
      }
    })();

    // Update stats every 30s.
    setInterval(updateStats, 30000);

    // ── Help Modal ──
    function toggleHelpModal() {
      document.getElementById('help-modal-overlay').classList.toggle('open');
    }
    function closeHelpModal(e) {
      // Only close if clicking the overlay background.
      if (e.target === document.getElementById('help-modal-overlay')) {
        document.getElementById('help-modal-overlay').classList.remove('open');
      }
    }

    // ── Role badge helper ──
    function roleBadge(role) {
      switch (role) {
        case 'admin': return '<span class="role-badge" title="Admin">👑</span>';
        case 'mod': return '<span class="role-badge" title="Moderator">🛡️</span>';
        case 'verified': return '<span class="role-badge" title="Verified">✦</span>';
        case 'donor': return '<span class="role-badge" title="Donor">💎</span>';
        default: return '';
      }
    }

    // ── User Context Menu ──
    let ctxMenuTarget = null; // { name, publicKey }
    const ctxMenu = document.getElementById('user-context-menu');

    function showUserContextMenu(e, name, publicKey) {
      e.preventDefault();
      e.stopPropagation();
      ctxMenuTarget = { name, publicKey };

      const isBot = publicKey && publicKey.startsWith('bot_');
      let html = '';
      if (isBot) {
        // Bot-specific context menu
        html += `<div class="ctx-item" style="font-weight:bold;color:var(--accent);pointer-events:none">🤖 ${esc(name)}</div>`;
        html += '<div class="ctx-sep"></div>';
        html += `<div class="ctx-item" onclick="botCommand('status')">📊 Status</div>`;
        html += `<div class="ctx-item" onclick="botCommand('summary')">📝 Today's Summary</div>`;
        html += `<div class="ctx-item" onclick="botCommand('tasks')">📋 Current Tasks</div>`;
        html += `<div class="ctx-item" onclick="botCommand('help')">❓ Help</div>`;
      } else {
        html += `<div class="ctx-item" onclick="viewProfileFromCtx()">👤 View Profile</div>`;
        html += `<div class="ctx-item" onclick="copyPublicKey()">📋 Copy public key</div>`;
        if (name !== myName) {
          html += `<div class="ctx-item" onclick="dmFromCtx()">💬 Direct Message</div>`;
          // Follow/unfollow toggle
          if (typeof myFollowing !== 'undefined' && myFollowing.has(publicKey)) {
            html += `<div class="ctx-item" onclick="followFromCtx(false)">❌ Unfollow</div>`;
          } else {
            html += `<div class="ctx-item" onclick="followFromCtx(true)">👁️ Follow</div>`;
          }
          // Block/unblock toggle.
          if (isBlocked(name)) {
            html += `<div class="ctx-item" onclick="unblockFromCtx()">✅ Unblock</div>`;
          } else {
            html += `<div class="ctx-item" onclick="blockFromCtx()">🚫 Block</div>`;
          }
          html += `<div class="ctx-item" onclick="reportUser()">🚩 Report</div>`;
          html += '<div class="ctx-sep"></div>';
          html += `<div class="ctx-item" onclick="ctxCommand('/kick')">👢 Kick</div>`;
          html += `<div class="ctx-item" onclick="ctxCommand('/mute')">🔇 Mute</div>`;
          html += `<div class="ctx-item" onclick="ctxCommand('/ban')">🚫 Ban</div>`;
          html += `<div class="ctx-item" onclick="ctxCommand('/verify')">✦ Verify</div>`;
        }
      }

      ctxMenu.innerHTML = html;
      if (window.twemoji) twemoji.parse(ctxMenu);

      // Position near click.
      const x = Math.min(e.clientX, window.innerWidth - 170);
      const y = Math.min(e.clientY, window.innerHeight - 200);
      ctxMenu.style.left = x + 'px';
      ctxMenu.style.top = y + 'px';
      ctxMenu.classList.add('open');
    }

    function hideContextMenu() {
      ctxMenu.classList.remove('open');
      ctxMenuTarget = null;
    }

    function copyPublicKey() {
      if (ctxMenuTarget && ctxMenuTarget.publicKey) {
        navigator.clipboard.writeText(ctxMenuTarget.publicKey).then(() => {
          addSystemMessage('Public key copied to clipboard.');
        }).catch(() => {
          addSystemMessage('Failed to copy key.');
        });
      }
      hideContextMenu();
    }

    function ctxCommand(cmd) {
      if (!ctxMenuTarget || !ws || ws.readyState !== WebSocket.OPEN) return;
      const msg = `${cmd} ${ctxMenuTarget.name}`;
      const timestamp = Date.now();
      ws.send(JSON.stringify({
        type: 'chat',
        from: myKey,
        from_name: myName,
        content: msg,
        timestamp: timestamp,
        channel: activeChannel,
      }));
      hideContextMenu();
    }

    function botCommand(cmd) {
      if (!ctxMenuTarget || !ws || ws.readyState !== WebSocket.OPEN) return;
      const content = `@Heron /${cmd}`;
      const timestamp = Date.now();
      ws.send(JSON.stringify({
        type: 'chat',
        from: myKey,
        from_name: myName,
        content: content,
        timestamp: timestamp,
        channel: activeChannel,
      }));
      hideContextMenu();
    }

    function reportUser() {
      if (!ctxMenuTarget || !ws || ws.readyState !== WebSocket.OPEN) return;
      const targetName = ctxMenuTarget.name;
      hideContextMenu();
      const reason = prompt(`Report ${targetName}?\nEnter a reason (optional):`);
      if (reason === null) return; // User cancelled
      const content = reason ? `/report ${targetName} ${reason}` : `/report ${targetName}`;
      const timestamp = Date.now();
      ws.send(JSON.stringify({
        type: 'chat',
        from: myKey,
        from_name: myName,
        content: content,
        timestamp: timestamp,
        channel: activeChannel,
      }));
    }

    function blockFromCtx() {
      if (!ctxMenuTarget) return;
      const name = ctxMenuTarget.name;
      hideContextMenu();
      blockUser(name);
    }

    function unblockFromCtx() {
      if (!ctxMenuTarget) return;
      const name = ctxMenuTarget.name;
      hideContextMenu();
      unblockUser(name);
    }

    function followFromCtx(doFollow) {
      if (!ctxMenuTarget) return;
      const pk = ctxMenuTarget.publicKey;
      hideContextMenu();
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: doFollow ? 'follow' : 'unfollow', target_key: pk }));
      }
    }

    function dmFromCtx() {
      if (!ctxMenuTarget) return;
      const name = ctxMenuTarget.name;
      const pk = ctxMenuTarget.publicKey;
      hideContextMenu();
      // DM permission check
      const myRole = (window.myPeerRole || '').toLowerCase();
      if (myRole !== 'admin' && myRole !== 'mod' && !myKey.startsWith('bot_')) {
        if (myRole !== 'verified' && myRole !== 'donor') {
          addSystemMessage('🔒 Verify your account to send DMs.');
          return;
        }
        if (typeof isFriend === 'function' && !isFriend(pk)) {
          addSystemMessage('🔒 You must be friends with this user to DM them. Use /follow ' + name);
          return;
        }
      }
      openDmConversation(pk, name);
    }

    function viewProfileFromCtx() {
      if (!ctxMenuTarget) return;
      const name = ctxMenuTarget.name;
      const pk = ctxMenuTarget.publicKey;
      hideContextMenu();
      requestViewProfile(name, pk);
    }

    // Close context menu on click outside.
    document.addEventListener('click', (e) => {
      if (!ctxMenu.contains(e.target)) hideContextMenu();
    });

    // Event delegation for peer list context menu clicks.
    document.getElementById('peer-list').addEventListener('click', function(e) {
      const peerEl = e.target.closest('.peer[data-username]');
      if (peerEl) {
        showUserContextMenu(e, peerEl.dataset.username, peerEl.dataset.pubkey);
      }
    });

    // Store peer data (with roles) for context menu lookups.
    let peerData = {};

    // ── Profile System ──
    let profileCache = {}; // name (lowercase) → { bio, socials }
    let lastProfileUpdateSent = 0;
    let pendingProfileView = null; // name we're waiting for profile_data on

    // Local storage for offline profile editing.
    function saveProfileLocal(bio, socials) {
      localStorage.setItem('humanity_profile', JSON.stringify({ bio, socials }));
    }
    function loadProfileLocal() {
      try {
        return JSON.parse(localStorage.getItem('humanity_profile') || '{}');
      } catch { return {}; }
    }

    // ── Edit Profile Modal ──
    function openEditProfileModal() {
      const overlay = document.getElementById('edit-profile-overlay');
      const local = loadProfileLocal();
      const socials = local.socials || {};
      document.getElementById('profile-bio').value = local.bio || '';
      document.getElementById('profile-website').value = socials.website || '';
      document.getElementById('profile-discord').value = socials.discord || '';
      document.getElementById('profile-twitter').value = socials.twitter || '';
      document.getElementById('profile-youtube').value = socials.youtube || '';
      document.getElementById('profile-github').value = socials.github || '';
      updateBioCounter();
      overlay.classList.add('open');
    }

    function closeEditProfileModal(e) {
      if (e.target === document.getElementById('edit-profile-overlay')) {
        closeEditProfileOverlay();
      }
    }
    function closeEditProfileOverlay() {
      document.getElementById('edit-profile-overlay').classList.remove('open');
    }

    function updateBioCounter() {
      const bio = document.getElementById('profile-bio').value;
      const counter = document.getElementById('bio-counter');
      counter.textContent = bio.length + ' / 280';
      counter.className = 'bio-counter' + (bio.length > 280 ? ' over' : bio.length > 240 ? ' warn' : '');
    }

    document.getElementById('profile-bio').addEventListener('input', updateBioCounter);

    function saveProfile() {
      const bio = document.getElementById('profile-bio').value.trim().substring(0, 280);
      const socials = {
        website: document.getElementById('profile-website').value.trim().substring(0, 200),
        discord: document.getElementById('profile-discord').value.trim().substring(0, 100),
        twitter: document.getElementById('profile-twitter').value.trim().substring(0, 100),
        youtube: document.getElementById('profile-youtube').value.trim().substring(0, 200),
        github: document.getElementById('profile-github').value.trim().substring(0, 200),
      };

      // Remove empty fields.
      const cleanSocials = {};
      for (const [k, v] of Object.entries(socials)) {
        if (v) cleanSocials[k] = v;
      }

      saveProfileLocal(bio, cleanSocials);

      // Send to server if connected.
      if (ws && ws.readyState === WebSocket.OPEN) {
        const now = Date.now();
        if (now - lastProfileUpdateSent < 30000) {
          addSystemMessage('⏳ Please wait 30 seconds between profile updates.');
        } else {
          lastProfileUpdateSent = now;
          ws.send(JSON.stringify({
            type: 'profile_update',
            bio: bio,
            socials: JSON.stringify(cleanSocials),
          }));
          addSystemMessage('Profile saved.');
        }
      } else {
        addSystemMessage('Profile saved locally. It will sync when you connect.');
      }

      closeEditProfileOverlay();
    }

    // Send stored profile on connect.
    function syncProfileOnConnect() {
      const local = loadProfileLocal();
      if (local.bio || (local.socials && Object.keys(local.socials).length > 0)) {
        const socialsStr = JSON.stringify(local.socials || {});
        ws.send(JSON.stringify({
          type: 'profile_update',
          bio: local.bio || '',
          socials: socialsStr,
        }));
        lastProfileUpdateSent = Date.now();
      }
    }

    // ── View Profile Modal ──
    function requestViewProfile(name, publicKey) {
      pendingProfileView = { name, publicKey };
      // Check cache first.
      const cached = profileCache[name.toLowerCase()];
      if (cached) {
        showViewProfileCard(name, publicKey, cached.bio, cached.socials);
        return;
      }
      // Request from server.
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'profile_request', name: name }));
        // Show loading state.
        document.getElementById('view-profile-content').innerHTML =
          '<div style="color:var(--text-muted);font-style:italic;">Loading profile…</div>';
        document.getElementById('view-profile-overlay').classList.add('open');
      }
    }

    function showViewProfileCard(name, publicKey, bio, socialsStr) {
      let socials = {};
      try { socials = JSON.parse(socialsStr || '{}'); } catch {}

      const isBot = publicKey && publicKey.startsWith('bot_');
      const identiconSrc = !isBot && publicKey
        ? generateIdenticon(publicKey, 64) : '';
      const identiconHtml = isBot
        ? '<span class="identicon-large" style="font-size:48px;line-height:64px;display:inline-block;width:64px;text-align:center;">🤖</span>'
        : (identiconSrc ? '<img src="' + identiconSrc + '" class="identicon-large" alt="">' : '');

      // Look up role.
      const peerRole = (peerData[publicKey] && peerData[publicKey].role) ? peerData[publicKey].role : '';
      const badge = roleBadge(peerRole);

      let html = '<div class="profile-card-header">';
      html += identiconHtml;
      html += '<div><div class="profile-name">' + esc(name) + badge + '</div></div>';
      html += '</div>';

      const hasBio = bio && bio.trim().length > 0;
      const hasSocials = Object.values(socials).some(v => v && v.trim());

      if (!hasBio && !hasSocials) {
        html += '<div class="profile-card-empty">This user hasn\'t set up their profile yet.</div>';
      } else {
        if (hasBio) {
          html += '<div class="profile-card-bio">' + esc(bio) + '</div>';
        }
        if (hasSocials) {
          html += '<div class="profile-card-socials">';
          if (socials.website) {
            const url = socials.website;
            if (url.startsWith('https://')) {
              html += '<div class="social-item"><span class="social-label">🌐 Website</span> <a href="' + esc(url) + '" target="_blank" rel="noopener">' + esc(url) + '</a></div>';
            } else {
              html += '<div class="social-item"><span class="social-label">🌐 Website</span> ' + esc(url) + '</div>';
            }
          }
          if (socials.discord) {
            html += '<div class="social-item"><span class="social-label">💬 Discord</span> ' + esc(socials.discord) + '</div>';
          }
          if (socials.twitter) {
            const handle = socials.twitter.replace(/^@/, '');
            html += '<div class="social-item"><span class="social-label">𝕏 Twitter</span> <a href="https://x.com/' + esc(handle) + '" target="_blank" rel="noopener">@' + esc(handle) + '</a></div>';
          }
          if (socials.youtube) {
            const yt = socials.youtube;
            if (yt.startsWith('https://')) {
              html += '<div class="social-item"><span class="social-label">▶️ YouTube</span> <a href="' + esc(yt) + '" target="_blank" rel="noopener">' + esc(yt) + '</a></div>';
            } else {
              const ytUrl = 'https://youtube.com/@' + yt;
              html += '<div class="social-item"><span class="social-label">▶️ YouTube</span> <a href="' + esc(ytUrl) + '" target="_blank" rel="noopener">@' + esc(yt) + '</a></div>';
            }
          }
          if (socials.github) {
            const gh = socials.github.replace(/^@/, '');
            html += '<div class="social-item"><span class="social-label">🐙 GitHub</span> <a href="https://github.com/' + esc(gh) + '" target="_blank" rel="noopener">' + esc(gh) + '</a></div>';
          }
          html += '</div>';
        }
      }

      // Public key (click to copy) — M-3: use DOM API instead of inline onclick.
      if (publicKey) {
        const shortPk = publicKey.length > 24 ? publicKey.substring(0, 24) + '…' : publicKey;
        html += '<div class="profile-card-key" id="profile-pk-copy" title="Click to copy full key">🔑 ' + esc(shortPk) + '</div>';
      }

      // Follow/friend status + button
      if (publicKey && publicKey !== myKey) {
        const friend = isFriend(publicKey);
        const following = isFollowing(publicKey);
        const followsYou = myFollowers.has(publicKey);
        let statusText = '';
        if (friend) statusText = '🤝 Friends (mutual follow)';
        else if (following && followsYou) statusText = '🤝 Friends';
        else if (following) statusText = '👁️ You follow this user';
        else if (followsYou) statusText = '👁️‍🗨️ Follows you';
        const btnLabel = following ? '❌ Unfollow' : '👁️ Follow';
        html += '<div style="margin-top:0.5rem;padding-top:0.5rem;border-top:1px solid var(--border);">';
        if (statusText) html += '<div style="font-size:0.75rem;color:var(--text-muted);margin-bottom:0.3rem;">' + statusText + '</div>';
        html += '<button id="profile-follow-btn" style="background:var(--accent);color:#fff;border:none;border-radius:6px;padding:0.3rem 0.8rem;font-size:0.78rem;cursor:pointer;">' + btnLabel + '</button>';
        html += '</div>';
      }

      document.getElementById('view-profile-content').innerHTML = html;
      // Attach click handler via DOM API (not inline onclick).
      if (publicKey) {
        const pkEl = document.getElementById('profile-pk-copy');
        if (pkEl) {
          pkEl.addEventListener('click', () => {
            navigator.clipboard.writeText(publicKey).then(() => addSystemMessage('Public key copied.'));
          });
        }
      }
      // Follow button handler
      if (publicKey && publicKey !== myKey) {
        const followBtn = document.getElementById('profile-follow-btn');
        if (followBtn) {
          followBtn.addEventListener('click', () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              const type = myFollowing.has(publicKey) ? 'unfollow' : 'follow';
              ws.send(JSON.stringify({ type, target_key: publicKey }));
              closeViewProfileOverlay();
            }
          });
        }
      }
      if (window.twemoji) twemoji.parse(document.getElementById('view-profile-content'));
      document.getElementById('view-profile-overlay').classList.add('open');
    }

    function closeViewProfileModal(e) {
      if (e.target === document.getElementById('view-profile-overlay')) {
        closeViewProfileOverlay();
      }
    }
    function closeViewProfileOverlay() {
      document.getElementById('view-profile-overlay').classList.remove('open');
      pendingProfileView = null;
    }

    // ── Block List (client-side) ──
    function getBlockList() {
      try { return JSON.parse(localStorage.getItem('humanity_blocks') || '[]'); }
      catch { return []; }
    }
    function setBlockList(list) {
      localStorage.setItem('humanity_blocks', JSON.stringify(list));
    }
    function isBlocked(name) {
      return getBlockList().some(b => b.toLowerCase() === name.toLowerCase());
    }

    function blockUser(name) {
      if (name.toLowerCase() === myName.toLowerCase()) {
        addSystemMessage("You can't block yourself.");
        return;
      }
      const list = getBlockList();
      if (list.some(b => b.toLowerCase() === name.toLowerCase())) {
        addSystemMessage(`${name} is already blocked.`);
        return;
      }
      list.push(name);
      setBlockList(list);
      addSystemMessage(`🚫 Blocked ${name}. Their messages are now hidden.`);
      reRenderMessagesForBlockChange();
      rerenderUserList();
    }

    function unblockUser(name) {
      const list = getBlockList();
      const idx = list.findIndex(b => b.toLowerCase() === name.toLowerCase());
      if (idx === -1) {
        addSystemMessage(`${name} is not blocked.`);
        return;
      }
      list.splice(idx, 1);
      setBlockList(list);
      addSystemMessage(`✅ Unblocked ${name}.`);
      reRenderMessagesForBlockChange();
      rerenderUserList();
    }

    function showBlockList() {
      const list = getBlockList();
      if (list.length === 0) {
        addSystemMessage('No blocked users.');
      } else {
        addSystemMessage('🚫 Blocked users: ' + list.join(', '));
      }
    }

    // Re-filter visible messages after block/unblock change.
    function reRenderMessagesForBlockChange() {
      const container = document.getElementById('messages');
      const msgs = container.querySelectorAll('.message[data-from]');
      msgs.forEach(el => {
        const authorEl = el.querySelector('.author');
        if (!authorEl) return;
        const authorName = authorEl.dataset.username;
        if (authorName && isBlocked(authorName)) {
          el.style.display = 'none';
        } else {
          el.style.display = '';
        }
      });
    }

    // Force re-render user list with updated block indicators.
    function rerenderUserList() {
      // Trigger a full_user_list refresh if we have cached data.
      // The user list is already rendered from updateUserList; just re-render peer-list.
      const list = document.getElementById('peer-list');
      const peers = list.querySelectorAll('.peer[data-username]');
      peers.forEach(el => {
        const name = el.dataset.username;
        if (!name) return;
        const blocked = isBlocked(name);
        // Add/remove blocked indicator.
        let indicator = el.querySelector('.block-indicator');
        if (blocked && !indicator) {
          const span = document.createElement('span');
          span.className = 'block-indicator';
          span.textContent = ' 🚫';
          span.title = 'Blocked';
          span.style.fontSize = '0.65rem';
          el.appendChild(span);
          el.style.textDecoration = 'line-through';
          el.style.opacity = '0.5';
        } else if (!blocked && indicator) {
          indicator.remove();
          el.style.textDecoration = '';
          el.style.opacity = el.classList.contains('is-you') ? '' : '';
          // Restore original opacity from online/offline status.
          if (el.style.opacity === '') el.removeAttribute('style');
        }
      });
    }

    // ── Import file handler (login screen) ──
    async function handleImportFile(event) {
      const file = event.target.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const jsonData = JSON.parse(text);
        const identity = await importIdentityFromJSON(jsonData);
        // Update state and connect
        document.getElementById('name-input').value = identity.name;
        myIdentity = identity;
        myKey = identity.publicKeyHex;
        myName = identity.name;
        addSystemMessage('✅ Identity imported successfully! Connecting...');
        connect();
      } catch (e) {
        const errEl = document.getElementById('login-error');
        errEl.textContent = '❌ Import failed: ' + e.message;
        errEl.style.display = 'block';
      }
      // Reset file input so the same file can be re-selected
      event.target.value = '';
    }

    // Handle /profile, /block, /unblock, /blocklist commands.
    // Patching into the existing sendMessage to intercept client-side commands.
    const _origSendMessage2 = sendMessage;
    sendMessage = async function() {
      const input = document.getElementById('msg-input');
      const val = input.value.trim();
      if (val === '/profile') {
        input.value = '';
        openEditProfileModal();
        return;
      }
      if (val === '/export') {
        input.value = '';
        downloadIdentityBackup(myName);
        return;
      }
      if (val === '/blocklist') {
        input.value = '';
        showBlockList();
        return;
      }
      if (val === '/dms') {
        input.value = '';
        // Request updated DM list from server.
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'chat', from: myKey, from_name: myName, content: '/dms', timestamp: Date.now(), channel: activeChannel }));
        }
        return;
      }
      if (val.startsWith('/block ') && !val.startsWith('/blocklist')) {
        const name = val.substring(7).trim();
        if (name) {
          input.value = '';
          blockUser(name);
          return;
        }
      }
      if (val.startsWith('/unblock ')) {
        const name = val.substring(9).trim();
        if (name) {
          input.value = '';
          unblockUser(name);
          return;
        }
      }
      if (val.startsWith('/follow ') && !val.startsWith('/follow-')) {
        const name = val.substring(8).trim();
        if (name && ws && ws.readyState === WebSocket.OPEN) {
          input.value = '';
          // Resolve name to key from peer list
          const targetKey = resolveNameToKey(name);
          if (targetKey) {
            ws.send(JSON.stringify({ type: 'follow', target_key: targetKey }));
          } else {
            addSystemMessage('User "' + name + '" not found in peer list.');
          }
          return;
        }
      }
      if (val.startsWith('/unfollow ')) {
        const name = val.substring(10).trim();
        if (name && ws && ws.readyState === WebSocket.OPEN) {
          input.value = '';
          const targetKey = resolveNameToKey(name);
          if (targetKey) {
            ws.send(JSON.stringify({ type: 'unfollow', target_key: targetKey }));
          } else {
            addSystemMessage('User "' + name + '" not found in peer list.');
          }
          return;
        }
      }
      if (val.startsWith('/group-create ')) {
        const name = val.substring(14).trim();
        if (name && ws && ws.readyState === WebSocket.OPEN) {
          input.value = '';
          ws.send(JSON.stringify({ type: 'group_create', name: name }));
          return;
        }
      }
      if (val.startsWith('/group-join ')) {
        const code = val.substring(12).trim();
        if (code && ws && ws.readyState === WebSocket.OPEN) {
          input.value = '';
          ws.send(JSON.stringify({ type: 'group_join', invite_code: code }));
          return;
        }
      }
      if (val.startsWith('/group-leave')) {
        input.value = '';
        if (activeGroupId && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({ type: 'group_leave', group_id: activeGroupId }));
        } else {
          addSystemMessage('You are not viewing a group. Switch to a group first.');
        }
        return;
      }
      if (val.startsWith('/group-invite')) {
        input.value = '';
        if (activeGroupId) {
          const group = myGroups.find(g => g.id === activeGroupId);
          if (group) {
            navigator.clipboard.writeText(group.invite_code).then(() => {
              addSystemMessage('📋 Invite code copied: ' + group.invite_code + ' — Share it with /group-join ' + group.invite_code);
            }).catch(() => {
              addSystemMessage('📋 Invite code: ' + group.invite_code + ' — Share it with /group-join ' + group.invite_code);
            });
          }
        } else {
          addSystemMessage('Switch to a group first to get its invite code.');
        }
        return;
      }
      // If in group view, send as group message.
      if (activeGroupId) {
        if (val && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'group_msg',
            group_id: activeGroupId,
            content: val,
          }));
          input.value = '';
          input.style.height = 'auto';
        }
        return;
      }
      // If in DM view, send as DM instead of chat.
      if (activeDmPartner) {
        // Client-side DM permission pre-check
        const myRole = (window.myPeerRole || '').toLowerCase();
        if (myRole !== 'admin' && myRole !== 'mod' && !myKey.startsWith('bot_')) {
          if (myRole !== 'verified' && myRole !== 'donor') {
            addSystemMessage('🔒 Verify your account to send DMs.');
            return;
          }
          if (!isFriend(activeDmPartner)) {
            addSystemMessage('🔒 You must be friends to DM this user. Use /follow <name> — if they follow you back, you\'ll be friends.');
            return;
          }
        }
        if (val && ws && ws.readyState === WebSocket.OPEN) {
          const peerEcdh = getPeerEcdhPublic(activeDmPartner);
          let dmPayload = {
            type: 'dm',
            from: myKey,
            from_name: myName,
            to: activeDmPartner,
            content: val,
            timestamp: Date.now(),
          };
          // E2EE: encrypt if both parties have ECDH keys.
          if (peerEcdh && myEcdhKeyPair) {
            const enc = await encryptDmContent(val, peerEcdh);
            if (enc) {
              dmPayload.content = enc.content;
              dmPayload.nonce = enc.nonce;
              dmPayload.encrypted = true;
            }
          }
          ws.send(JSON.stringify(dmPayload));
          // Show locally immediately (plaintext).
          addDmMessage(myName, val, Date.now(), myKey, activeDmPartner, false);
          input.value = '';
          input.style.height = 'auto';
        }
        return;
      }
      await _origSendMessage2();
    };

    // ── DM State ──
    let activeDmPartner = null; // Public key of active DM partner, or null for channel view.
    let activeDmPartnerName = '';
    let dmConversations = []; // Array of { partner_key, partner_name, last_message, last_timestamp, unread_count }

    /** Switch to DM conversation view. */
    function openDmConversation(partnerKey, partnerName) {
      activeDmPartner = partnerKey;
      activeDmPartnerName = partnerName;

      // Switch to DMs tab in sidebar.
      if (typeof switchSidebarTab === 'function') switchSidebarTab('dms', true);

      // Update sidebar highlighting.
      renderDmList();
      renderChannelList(); // Deselect channels

      // Hide pin bar in DM view.
      document.getElementById('pin-bar').style.display = 'none';
      document.getElementById('pin-list').classList.remove('open');

      // Update channel header.
      const header = document.getElementById('channel-header');
      header.innerHTML = `<span class="ch-name" style="cursor:pointer;" onclick="closeDmView()">← Back</span> <span class="ch-name">💬 ${esc(partnerName)}</span>`;
      header.style.display = 'block';

      // Clear messages area.
      document.getElementById('messages').innerHTML = '';

      // Enable input.
      const input = document.getElementById('msg-input');
      input.disabled = false;
      input.placeholder = `Message ${partnerName}…`;
      document.getElementById('send-btn').disabled = false;

      // Request DM history from server.
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'dm_open', partner: partnerKey }));
      }

      if (isMobile()) closeSidebars();
    }

    /** Close DM view and return to channel view. */
    function closeDmView() {
      activeDmPartner = null;
      activeDmPartnerName = '';
      renderDmList();
      switchChannel(activeChannel);
    }

    /** Add a DM message to the message area. */
    function addDmMessage(author, body, timestamp, fromKey, toKey, isEncrypted) {
      const el = document.createElement('div');
      el.className = 'message dm-message';
      el.dataset.from = fromKey;
      el.dataset.timestamp = timestamp;

      const time = formatTime(timestamp);
      const isMe = fromKey === myKey;

      const isBotMsg2 = fromKey && fromKey.startsWith('bot_');
      const identiconSrc = (!isBotMsg2 && fromKey) ? generateIdenticon(fromKey, 20) : '';
      const identiconHtml = isBotMsg2 ? '<span class="identicon" style="font-size:18px;line-height:20px;">🤖</span>' : (identiconSrc ? `<img src="${identiconSrc}" class="identicon" alt="">` : '');
      const e2eeBadge = isEncrypted ? '<span title="End-to-end encrypted" style="font-size:0.65rem;opacity:0.6;margin-left:0.3rem;">🔒</span>' : '';

      el.innerHTML = `
        <div class="meta">
          ${identiconHtml}
          <span class="author${isMe ? ' you' : ''}">${esc(author)}</span>
          <span class="time">${time}</span>${e2eeBadge}
        </div>
        <div class="body">${formatBody(body)}</div>
      `;

      appendMessage(el);
      if (window.twemoji) twemoji.parse(el);
    }

    /** Render the DM conversation list in the sidebar. */
    function renderDmList() {
      const list = document.getElementById('dm-list');
      if (dmConversations.length === 0) {
        list.innerHTML = '<div style="font-size:0.7rem;color:var(--text-muted);padding:0.3rem 0.5rem;">No conversations yet</div>';
        return;
      }

      list.innerHTML = dmConversations.map(c => {
        const isActive = activeDmPartner === c.partner_key;
        const unread = c.unread_count > 0 ? '<span class="dm-unread"></span>' : '';
        const preview = c.last_message.length > 30 ? c.last_message.substring(0, 30) + '…' : c.last_message;
        const timeStr = formatTime(c.last_timestamp);
        return `<div class="dm-item${isActive ? ' active' : ''}" onclick="openDmConversation('${esc(c.partner_key)}', '${esc(c.partner_name)}')">
          <div style="flex:1;min-width:0;">
            <div class="dm-name">${esc(c.partner_name)} ${unread}</div>
            <div class="dm-preview">${esc(preview)}</div>
          </div>
          <div class="dm-time">${timeStr}</div>
        </div>`;
      }).join('');
      if (window.twemoji) twemoji.parse(list);
    }

    // ── Sidebar Tab Navigation ──
    (function initSidebarTabs() {
      const SIDEBAR_TAB_KEY = 'humanity_sidebar_tab';
      const SERVER_ORDER_KEY = 'humanity_server_order';
      const SERVER_COLLAPSE_KEY = 'humanity_server_collapsed';

      // Tab click handler via event delegation — register FIRST before anything that might throw
      document.getElementById('sidebar-tabs').addEventListener('click', function(e) {
        const tab = e.target.closest('.sidebar-tab');
        if (!tab) return;
        const tabName = tab.getAttribute('data-tab');
        if (tabName) switchSidebarTab(tabName, true);
      });

      // Restore saved tab
      const savedTab = localStorage.getItem(SIDEBAR_TAB_KEY) || 'servers';
      try { switchSidebarTab(savedTab, false); } catch(e) { console.warn('Sidebar init error:', e); }

      function switchSidebarTab(tabName, save) {
        // Update tab buttons
        document.querySelectorAll('#sidebar-tabs .sidebar-tab').forEach(btn => {
          btn.classList.toggle('active', btn.getAttribute('data-tab') === tabName);
        });
        // Update tab content panels
        document.querySelectorAll('.sidebar-tab-content').forEach(panel => {
          panel.classList.toggle('active', panel.id === 'tab-' + tabName);
        });
        if (save) localStorage.setItem(SIDEBAR_TAB_KEY, tabName);
        // Render the active tab's content
        if (tabName === 'servers') renderServerList();
        if (tabName === 'dms') renderDmList();
      }
      window.switchSidebarTab = switchSidebarTab;

      // ── Server List Rendering ──
      function getServerOrder() {
        try {
          const order = JSON.parse(localStorage.getItem(SERVER_ORDER_KEY));
          if (Array.isArray(order)) return order;
        } catch(_) {}
        return null;
      }

      function getCollapsedServers() {
        try {
          const c = JSON.parse(localStorage.getItem(SERVER_COLLAPSE_KEY));
          if (Array.isArray(c)) return new Set(c);
        } catch(_) {}
        return new Set();
      }

      function saveCollapsedServers(set) {
        localStorage.setItem(SERVER_COLLAPSE_KEY, JSON.stringify([...set]));
      }

      // Federated servers cache (fetched from API).
      var federatedServers = [];
      var federatedServersFetched = false;

      async function fetchFederatedServers() {
        try {
          const resp = await fetch('/api/federation/servers');
          if (resp.ok) {
            federatedServers = await resp.json();
            federatedServersFetched = true;
          }
        } catch (e) {
          console.warn('Failed to fetch federated servers:', e);
        }
      }

      function renderServerList() {
        const container = document.getElementById('server-list');
        if (!container) return;

        // Fetch federated servers if not yet loaded.
        if (!federatedServersFetched) {
          fetchFederatedServers().then(() => renderServerList());
        }

        // Current server (always first, highlighted).
        const collapsed = getCollapsedServers();
        const isCollapsed = collapsed.has('Humanity');
        const myRoleCh = (window.myPeerRole || '').toLowerCase();
        const channelsHtml = channelList.map(ch => {
          const isActive = ch.id === activeChannel && !activeDmPartner;
          const title = ch.description ? ` title="${esc(ch.description)}"` : '';
          const lock = ch.read_only ? ' 🔒' : '';
          const cogHtml = (myRoleCh === 'admin' || myRoleCh === 'mod') ? `<span class="channel-cog" data-cog-type="text" data-cog-id="${esc(ch.id)}" data-cog-name="${esc(ch.name)}">⚙️</span>` : '';
          return `<div class="channel-item${isActive ? ' active' : ''}"${title} data-channel-id="${esc(ch.id)}">${cogHtml}${esc(ch.name)}${lock}</div>`;
        }).join('');

        // Text channel create button (admin/mod only)
        let createChannelBtn = '';
        if (myRoleCh === 'admin' || myRoleCh === 'mod') {
          createChannelBtn = '<div style="padding:0.2rem 0;"><button class="vr-btn" data-action="create-text-channel" style="width:100%;margin-top:0.2rem;font-size:0.7rem;">+ Create Channel</button></div>';
        }

        // Persistent voice channels section
        const voiceChannels = window._voiceChannels || [];
        let voiceHtml = '<div class="voice-rooms-section"><h4>🔊 Voice Channels</h4>';
        for (const vc of voiceChannels) {
          const inRoom = vc.participants.some(p => p.public_key === myKey);
          const hasParticipants = vc.participants.length > 0;
          const dimClass = hasParticipants ? '' : ' vc-empty';
          const vcCogHtml = (myRoleCh === 'admin' || myRoleCh === 'mod') ? `<span class="channel-cog" data-cog-type="voice" data-cog-id="${vc.id}" data-cog-name="${esc(vc.name)}">⚙️</span>` : '';
          voiceHtml += `<div class="voice-room-item${inRoom ? ' in-room' : ''}${dimClass}" data-vc-id="${vc.id}">
            <div class="vr-name">${vcCogHtml}🔊 ${esc(vc.name)}${hasParticipants ? ' <span class="vr-count">(' + vc.participants.length + ')</span>' : ''}</div>`;
          if (hasParticipants) {
            voiceHtml += '<div class="vr-participants">';
            for (const p of vc.participants) {
              voiceHtml += `<div class="vr-participant" data-participant-key="${p.public_key}">🎤 ${esc(p.display_name)}</div>`;
            }
            voiceHtml += '</div>';
          }
          voiceHtml += '<div style="margin-top:0.2rem;">';
          if (inRoom) {
            voiceHtml += '<button class="vr-btn vr-leave" data-action="vc-leave">Leave</button>';
          } else {
            voiceHtml += `<button class="vr-btn vr-join" data-action="vc-join" data-vc-id="${vc.id}">Join</button>`;
          }
          if (myRoleCh === 'admin' || myRoleCh === 'mod') {
            voiceHtml += ` <button class="vr-btn vr-delete" data-action="vc-delete" data-vc-id="${vc.id}" style="float:right;color:var(--text-muted);font-size:0.65rem;" title="Delete voice channel">✕</button>`;
          }
          voiceHtml += '</div></div>';
        }
        if (myRoleCh === 'admin' || myRoleCh === 'mod') {
          voiceHtml += '<button class="vr-btn" data-action="vc-create" style="margin-top:0.3rem;width:100%;">+ Create Voice Channel</button>';
        }
        voiceHtml += '</div>';

        let html = `<div class="server-group${isCollapsed ? ' collapsed' : ''}" data-server="Humanity">
          <div class="server-group-header" data-server-toggle="Humanity" style="font-weight:bold;">
            <span class="collapse-arrow">▼</span>
            <span>🟢 🅷 Humanity</span>
          </div>
          <div class="server-group-channels">${channelsHtml}${createChannelBtn}${voiceHtml}</div>
        </div>`;

        // Federated servers.
        if (federatedServers.length > 0) {
          html += '<div style="padding:0.3rem 0.5rem 0.1rem;font-size:0.7rem;color:var(--text-muted);text-transform:uppercase;letter-spacing:0.05em;">Federation</div>';
          for (const s of federatedServers) {
            const tierBadge = s.trust_tier === 3 ? '🟢' : s.trust_tier === 2 ? '🟡' : s.trust_tier === 1 ? '🔵' : '⚪';
            const statusDot = s.status === 'online' ? '🟢' : s.status === 'unreachable' ? '⚫' : '🟡';
            html += `<div class="server-group" data-server="${esc(s.name)}">
              <div class="server-group-header" data-federated-url="${esc(s.url)}" title="Tier ${s.trust_tier} — ${esc(s.status)}\n${esc(s.url)}">
                <span>${statusDot} ${tierBadge} ${esc(s.name)}</span>
              </div>
            </div>`;
          }
        }

        // Add Server button (only show for admins).
        const myRole = (window.myPeerRole || '').toLowerCase();
        if (myRole === 'admin') {
          html += `<div style="padding:0.4rem 0.5rem;">
            <button onclick="promptAddServer()" style="font-size:0.75rem;padding:0.2rem 0.5rem;cursor:pointer;background:var(--bg-hover);border:1px solid var(--border);border-radius:4px;color:var(--text-primary);width:100%;">+ Add Server</button>
          </div>`;
        }

        container.innerHTML = html;
        if (window.twemoji) twemoji.parse(container);
        if (typeof renderUnreadDots === 'function') renderUnreadDots();
      }
      window.renderServerList = renderServerList;
      window.switchSidebarTab = switchSidebarTab;

      // Prompt to add a federated server via /server-add command.
      function promptAddServer() {
        const url = prompt('Enter server URL (e.g. https://chat.example.com):');
        if (!url) return;
        const name = prompt('Server name (optional):') || '';
        const cmd = name ? `/server-add ${url} ${name}` : `/server-add ${url}`;
        // Send the command as a chat message (the server intercepts slash commands).
        if (ws && ws.readyState === WebSocket.OPEN) {
          const msg = { type: 'chat', content: cmd, timestamp: Date.now(), channel: activeChannel || 'general' };
          ws.send(JSON.stringify(msg));
        }
        // Refresh after a delay to pick up the new server.
        setTimeout(() => { federatedServersFetched = false; renderServerList(); }, 3000);
      }
      window.promptAddServer = promptAddServer;

      // Event delegation for server list interactions
      document.getElementById('server-list').addEventListener('click', function(e) {
        // Federated server click — navigate to it.
        const fedHeader = e.target.closest('[data-federated-url]');
        if (fedHeader) {
          const url = fedHeader.getAttribute('data-federated-url');
          if (url && confirm(`Switch to server: ${url}?\n\nThis will open the server in a new tab.`)) {
            window.open(url, '_blank');
          }
          return;
        }
        // Toggle server collapse
        const toggle = e.target.closest('[data-server-toggle]');
        if (toggle) {
          const serverName = toggle.getAttribute('data-server-toggle');
          const group = toggle.closest('.server-group');
          const collapsed = getCollapsedServers();
          if (group.classList.contains('collapsed')) {
            group.classList.remove('collapsed');
            collapsed.delete(serverName);
          } else {
            group.classList.add('collapsed');
            collapsed.add(serverName);
          }
          saveCollapsedServers(collapsed);
          return;
        }
        // Channel click (skip if clicking the settings cog)
        if (e.target.closest('.channel-cog')) return;
        const chItem = e.target.closest('.channel-item');
        if (chItem) {
          const channelId = chItem.getAttribute('data-channel-id');
          if (channelId) switchChannel(channelId);
          return;
        }
        // Voice channel actions (event delegation — no inline onclick)
        const actionBtn = e.target.closest('[data-action]');
        if (actionBtn) {
          const action = actionBtn.getAttribute('data-action');
          if (action === 'vc-join') {
            const vcId = actionBtn.getAttribute('data-vc-id');
            if (vcId) joinVoiceRoom(vcId);
          } else if (action === 'vc-leave') {
            leaveVoiceRoom();
          } else if (action === 'vc-delete') {
            const vcId = actionBtn.getAttribute('data-vc-id');
            if (vcId) deleteVoiceChannel(vcId);
          } else if (action === 'vc-create') {
            createVoiceRoom();
          } else if (action === 'create-text-channel') {
            const name = prompt('Channel name (letters, numbers, dashes, underscores):');
            if (name && name.trim() && ws && ws.readyState === WebSocket.OPEN) {
              const cmd = '/channel-create ' + name.trim().toLowerCase();
              ws.send(JSON.stringify({ type: 'chat', content: cmd, timestamp: Date.now(), channel: activeChannel || 'general' }));
            }
          }
          return;
        }
      });
    })();

    // ── Mobile Sidebar Management ──
    function isMobile() {
      return window.innerWidth <= 640;
    }

    function toggleSidebar(sidebarId) {
      const sidebar = document.getElementById(sidebarId);
      const overlay = document.getElementById('sidebar-overlay');
      const otherSidebar = sidebarId === 'sidebar'
        ? document.getElementById('right-sidebar')
        : document.getElementById('sidebar');

      // Close the other sidebar first.
      otherSidebar.classList.remove('open');

      if (sidebar.classList.contains('open')) {
        sidebar.classList.remove('open');
        overlay.classList.remove('open');
      } else {
        sidebar.classList.add('open');
        if (isMobile()) overlay.classList.add('open');
      }
    }

    function closeSidebars() {
      document.getElementById('sidebar').classList.remove('open');
      document.getElementById('right-sidebar').classList.remove('open');
      document.getElementById('sidebar-overlay').classList.remove('open');
    }

    // Close sidebars when tapping the overlay backdrop.
    document.getElementById('sidebar-overlay').addEventListener('click', closeSidebars);

    // ── Close sidebar on channel select (mobile) ──
    // Patch switchChannel to close sidebar on mobile.
    const _origSwitchChannel = switchChannel;
    switchChannel = function(channelId) {
      // Clear unread for this channel.
      clearUnread(channelId);
      _origSwitchChannel(channelId);
      if (isMobile()) closeSidebars();
    };

    // ── Unread Indicators ──
    // Track unread state per channel.
    var unreadChannels = new Set();

    function markUnread(channelId) {
      if (channelId === activeChannel) return; // Don't mark current channel.
      unreadChannels.add(channelId);
      renderUnreadDots();
    }

    function clearUnread(channelId) {
      unreadChannels.delete(channelId);
      renderUnreadDots();
    }

    function renderUnreadDots() {
      document.querySelectorAll('.channel-item').forEach(el => {
        // Get the channel id from data attribute or onclick attribute.
        let chId = el.getAttribute('data-channel-id');
        if (!chId) {
          const onclick = el.getAttribute('onclick') || '';
          const match = onclick.match(/switchChannel\('([^']+)'\)/);
          if (!match) return;
          chId = match[1];
        }

        // Remove existing dot.
        const existingDot = el.querySelector('.unread-dot');
        if (existingDot) existingDot.remove();
        el.classList.remove('has-unread');

        if (unreadChannels.has(chId)) {
          el.classList.add('has-unread');
          const dot = document.createElement('span');
          dot.className = 'unread-dot';
          el.appendChild(dot);
        }
      });
    }

    // Hook into handleMessage to track unread for other channels.
    const _origHandleMessage2 = handleMessage;
    handleMessage = function(msg) {
      // Intercept chat messages for other channels BEFORE the original handler skips them.
      if (msg.type === 'chat') {
        const msgChannel = msg.channel || 'general';
        if (msgChannel !== activeChannel) {
          markUnread(msgChannel);
        }
      }
      _origHandleMessage2(msg);
    };

    // ── Improved Context Menu Positioning ──
    // Patch showUserContextMenu to prevent overflow on mobile.
    const _origShowCtxMenu = showUserContextMenu;
    showUserContextMenu = function(e, name, publicKey) {
      _origShowCtxMenu(e, name, publicKey);
      // Reposition if overflowing.
      const menu = document.getElementById('user-context-menu');
      const rect = menu.getBoundingClientRect();
      const vw = window.innerWidth;
      const vh = window.innerHeight;

      if (rect.right > vw) {
        menu.style.left = Math.max(4, vw - rect.width - 8) + 'px';
      }
      if (rect.bottom > vh) {
        menu.style.top = Math.max(4, vh - rect.height - 8) + 'px';
      }
      if (rect.left < 0) {
        menu.style.left = '4px';
      }
      if (rect.top < 0) {
        menu.style.top = '4px';
      }
    };

    // ── Mobile: Tap message to show/hide action buttons ──
    if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
      document.getElementById('messages').addEventListener('click', function(e) {
        const msgEl = e.target.closest('.message:not(.system)');
        if (!msgEl) return;
        // Don't interfere with button clicks, links, quotes, images.
        if (e.target.closest('button, a, .quote-block, .img-placeholder, .img-loaded, .reaction-badge')) return;

        // Toggle mobile-selected on this message, deselect others.
        const wasSelected = msgEl.classList.contains('mobile-selected');
        document.querySelectorAll('.message.mobile-selected').forEach(m => m.classList.remove('mobile-selected'));
        if (!wasSelected) {
          msgEl.classList.add('mobile-selected');
        }
      });
    }

    // ── Improved Timestamp: "Yesterday" format ──
    // Override formatTime to show "Yesterday HH:MM" for yesterday's messages.
    formatTime = function(ts) {
      const d = new Date(ts);
      const now = new Date();
      const time = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      // Same day.
      if (d.toDateString() === now.toDateString()) {
        return time;
      }

      // Yesterday.
      const yesterday = new Date(now);
      yesterday.setDate(yesterday.getDate() - 1);
      if (d.toDateString() === yesterday.toDateString()) {
        return 'Yesterday ' + time;
      }

      // Same year.
      if (d.getFullYear() === now.getFullYear()) {
        return d.toLocaleDateString([], { month: 'short', day: 'numeric' }) + ' ' + time;
      }

      // Different year.
      return d.toLocaleDateString([], { month: 'short', day: 'numeric', year: 'numeric' }) + ' ' + time;
    };

    // ── Reaction picker: better mobile positioning ──
    const _origShowReactionPicker = showReactionPicker;
    showReactionPicker = function(btn, targetFrom, targetTs, msgEl) {
      // Close any existing picker.
      document.querySelectorAll('.reaction-picker').forEach(p => p.remove());

      const picker = document.createElement('div');
      picker.className = 'reaction-picker';
      // Base styles.
      picker.style.cssText = 'position:absolute;background:var(--bg-secondary);border:1px solid var(--border);border-radius:8px;padding:0.3rem;display:flex;flex-wrap:wrap;gap:0.2rem;z-index:20;box-shadow:0 4px 12px rgba(0,0,0,0.4);';

      if (isMobile()) {
        // On mobile: position below the message, centered, larger buttons.
        picker.style.position = 'relative';
        picker.style.marginTop = '0.3rem';
        picker.style.justifyContent = 'center';
      } else {
        picker.style.top = '-2rem';
        picker.style.right = '0';
      }

      REACTION_EMOJIS.forEach(emoji => {
        const emojiBtn = document.createElement('span');
        emojiBtn.textContent = emoji;
        const size = isMobile() ? 'padding:0.35rem 0.45rem;font-size:1.2rem;min-width:36px;text-align:center;' : 'padding:0.15rem 0.25rem;font-size:0.9rem;';
        emojiBtn.style.cssText = 'cursor:pointer;border-radius:4px;' + size;
        emojiBtn.onmouseover = () => emojiBtn.style.background = 'var(--bg-hover)';
        emojiBtn.onmouseout = () => emojiBtn.style.background = '';
        emojiBtn.onclick = (e) => {
          e.stopPropagation();
          sendReaction(targetFrom, targetTs, emoji);
          picker.remove();
        };
        picker.appendChild(emojiBtn);
      });
      if (window.twemoji) twemoji.parse(picker);

      msgEl.style.position = 'relative';
      msgEl.appendChild(picker);

      // Close picker on click elsewhere.
      setTimeout(() => {
        document.addEventListener('click', function closePicker(e) {
          if (!picker.contains(e.target)) {
            picker.remove();
            document.removeEventListener('click', closePicker);
          }
        });
      }, 0);
    };
  </script>

  <script>
    // ── WebRTC Config (shared by rooms and 1-on-1 calls) ──
    const rtcConfig = {
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' },
        { urls: 'stun:stun1.l.google.com:19302' },
        { urls: 'turn:united-humanity.us:3478', username: 'humanity', credential: 'turnRelay2026!secure' },
        { urls: 'turns:united-humanity.us:5349', username: 'humanity', credential: 'turnRelay2026!secure' },
      ],
    };

    // ── Voice Channels (Persistent, SQLite-backed) ──
    window._voiceChannels = [];
    window._roomPeerConnections = {}; // key → RTCPeerConnection for mesh
    window._roomLocalStream = null;
    window._currentRoomId = null;

    function createVoiceRoom() {
      const name = prompt('Voice channel name:');
      if (!name || !name.trim()) return;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'voice_room', action: 'create', room_name: name.trim() }));
      }
    }

    function joinVoiceRoom(roomId) {
      if (window._currentRoomId) {
        addSystemMessage('Leave your current voice channel first.');
        return;
      }
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'voice_room', action: 'join', room_id: String(roomId) }));
        window._currentRoomId = String(roomId);
        setupRoomAudio();
      }
    }

    function leaveVoiceRoom() {
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'voice_room', action: 'leave' }));
      }
      cleanupRoomAudio();
    }

    function deleteVoiceChannel(vcId) {
      if (!confirm('Delete this voice channel permanently?')) return;
      if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'voice_room', action: 'delete', room_id: String(vcId) }));
      }
    }

    async function setupRoomAudio() {
      try {
        window._roomLocalStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }, video: false });
      } catch (e) {
        addSystemMessage('⚠️ Microphone access denied.');
        leaveVoiceRoom();
        return;
      }
      // Wait for voice_room_update to know who's in the room, then connect
    }

    function cleanupRoomAudio() {
      if (window._roomLocalStream) {
        window._roomLocalStream.getTracks().forEach(t => t.stop());
        window._roomLocalStream = null;
      }
      for (const [key, pc] of Object.entries(window._roomPeerConnections)) {
        pc.close();
      }
      window._roomPeerConnections = {};
      window._currentRoomId = null;
      // Remove room audio elements
      document.querySelectorAll('.room-remote-audio').forEach(el => el.remove());
      if (typeof renderServerList === 'function') renderServerList();
    }

    async function connectToRoomPeer(peerKey, peerName, roomId, isCaller) {
      if (window._roomPeerConnections[peerKey]) return; // already connected
      const pc = new RTCPeerConnection(rtcConfig);
      window._roomPeerConnections[peerKey] = pc;

      if (window._roomLocalStream) {
        window._roomLocalStream.getTracks().forEach(t => pc.addTrack(t, window._roomLocalStream));
      }

      pc.ontrack = (event) => {
        const audio = document.createElement('audio');
        audio.srcObject = event.streams[0];
        audio.autoplay = true;
        audio.playsInline = true;
        audio.className = 'room-remote-audio';
        audio.dataset.peerKey = peerKey;
        document.body.appendChild(audio);
        // Mobile browsers block autoplay — explicitly play with user gesture fallback
        const playPromise = audio.play();
        if (playPromise) {
          playPromise.catch(() => {
            console.warn('Autoplay blocked for peer', peerKey, '— waiting for user interaction');
            const resumeAudio = () => {
              audio.play().catch(() => {});
              document.removeEventListener('click', resumeAudio);
              document.removeEventListener('touchstart', resumeAudio);
            };
            document.addEventListener('click', resumeAudio, { once: true });
            document.addEventListener('touchstart', resumeAudio, { once: true });
            addSystemMessage('⚠️ Tap anywhere to unmute incoming audio (browser autoplay restriction).');
          });
        }
      };

      pc.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'voice_room_signal',
            from: myKey,
            to: peerKey,
            room_id: roomId,
            signal_type: 'ice',
            data: event.candidate.toJSON()
          }));
        }
      };

      pc.onconnectionstatechange = () => {
        console.log(`Voice peer ${peerKey.substring(0,8)}: ${pc.connectionState}`);
        if (pc.connectionState === 'connected') {
          addSystemMessage(`🔊 Voice connected to peer`);
        } else if (pc.connectionState === 'failed') {
          addSystemMessage(`⚠️ Voice connection failed — may need TURN server for NAT traversal`);
          pc.close();
          delete window._roomPeerConnections[peerKey];
          const audioEl = document.querySelector(`.room-remote-audio[data-peer-key="${peerKey}"]`);
          if (audioEl) audioEl.remove();
        } else if (pc.connectionState === 'disconnected') {
          // Give it a moment — might recover
          setTimeout(() => {
            if (pc.connectionState === 'disconnected') {
              pc.close();
              delete window._roomPeerConnections[peerKey];
              const audioEl = document.querySelector(`.room-remote-audio[data-peer-key="${peerKey}"]`);
              if (audioEl) audioEl.remove();
            }
          }, 5000);
        }
      };
      pc.onicegatheringstatechange = () => {
        console.log(`Voice ICE gathering: ${pc.iceGatheringState}`);
      };

      if (isCaller) {
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({
          type: 'voice_room_signal',
          from: myKey,
          to: peerKey,
          room_id: roomId,
          signal_type: 'offer',
          data: offer
        }));
      }
    }

    // Handle voice_channel_list, voice_room_update, and voice_room_signal
    const _origHandleMessageVR = handleMessage;
    handleMessage = function(msg) {
      if (msg.type === 'voice_channel_list') {
        window._voiceChannels = (msg.channels || []).map(c => ({
          id: c.id,
          name: c.name,
          participants: (c.participants || []).map(p => ({
            public_key: p.public_key,
            display_name: p.display_name,
            muted: p.muted || false
          }))
        }));
        if (typeof renderServerList === 'function') renderServerList();
        // If we're in a room, connect to any new participants
        if (window._currentRoomId && window._roomLocalStream) {
          const ch = window._voiceChannels.find(c => String(c.id) === String(window._currentRoomId));
          if (ch) {
            for (const p of ch.participants) {
              if (p.public_key !== myKey && !window._roomPeerConnections[p.public_key]) {
                connectToRoomPeer(p.public_key, p.display_name, String(window._currentRoomId), true);
              }
            }
          } else {
            cleanupRoomAudio();
          }
        }
        return;
      }
      // Legacy voice_room_update — convert to voice_channel_list format
      if (msg.type === 'voice_room_update') {
        // Handled by voice_channel_list now; ignore.
        return;
      }
      if (msg.type === 'voice_room_signal') {
        handleVoiceRoomSignal(msg);
        return;
      }
      _origHandleMessageVR(msg);
    };

    async function handleVoiceRoomSignal(msg) {
      if (msg.to !== myKey) return;
      const peerKey = msg.from;
      const roomId = msg.room_id;

      if (msg.signal_type === 'new_participant') {
        // New person joined — they'll send us an offer, just wait
        return;
      }

      if (msg.signal_type === 'offer') {
        // Someone is sending us an offer — create connection and answer
        await connectToRoomPeer(peerKey, '', roomId, false);
        const pc = window._roomPeerConnections[peerKey];
        if (pc) {
          await pc.setRemoteDescription(new RTCSessionDescription(msg.data));
          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          ws.send(JSON.stringify({
            type: 'voice_room_signal',
            from: myKey,
            to: peerKey,
            room_id: roomId,
            signal_type: 'answer',
            data: answer
          }));
        }
        return;
      }

      if (msg.signal_type === 'answer') {
        const pc = window._roomPeerConnections[peerKey];
        if (pc) await pc.setRemoteDescription(new RTCSessionDescription(msg.data));
        return;
      }

      if (msg.signal_type === 'ice') {
        const pc = window._roomPeerConnections[peerKey];
        if (pc) {
          try { await pc.addIceCandidate(new RTCIceCandidate(msg.data)); } catch (e) {}
        }
        return;
      }
    }

    // Add voice room button styles
    (function() {
      const style = document.createElement('style');
      style.textContent = `
        .vr-btn { font-size:0.7rem; padding:0.15rem 0.4rem; cursor:pointer; border-radius:4px; border:1px solid var(--border); background:var(--bg-input); color:var(--text-primary); }
        .vr-btn:hover { background:var(--bg-hover); }
        .vr-join { color:var(--success); border-color:var(--success); }
        .vr-leave { color:#e74c3c; border-color:#e74c3c; }
      `;
      document.head.appendChild(style);
    })();

    // ── Voice Control Bar + Speaking Indicators + Channel Cog ──
    (function() {
      // Voice control bar state
      let vcMuted = false;
      let vcVolume = 100;
      let audioCtx = null;
      let localAnalyser = null;
      let speakingPollInterval = null;
      let remoteAnalysers = {}; // peerKey → { analyser, source, interval }

      window.toggleVoiceRoomMute = function() {
        if (!window._roomLocalStream) return;
        vcMuted = !vcMuted;
        window._roomLocalStream.getAudioTracks().forEach(t => { t.enabled = !vcMuted; });
        const btn = document.getElementById('vc-mute-btn');
        btn.textContent = vcMuted ? '🔇' : '🎤';
        btn.classList.toggle('vc-muted', vcMuted);
        btn.title = vcMuted ? 'Unmute' : 'Mute';
      };

      window.setVoiceRoomVolume = function(val) {
        vcVolume = parseInt(val);
        document.querySelectorAll('.room-remote-audio').forEach(el => {
          el.volume = vcVolume / 100;
        });
      };

      function updateVoiceControlBar() {
        const bar = document.getElementById('voice-control-bar');
        if (!bar) return;
        if (window._currentRoomId && window._roomLocalStream) {
          const ch = (window._voiceChannels || []).find(c => String(c.id) === String(window._currentRoomId));
          const name = ch ? ch.name : 'Unknown';
          document.getElementById('vc-bar-channel-name').textContent = '🔊 Connected to: ' + name;
          bar.classList.add('active');
        } else {
          bar.classList.remove('active');
          stopSpeakingDetection();
        }
      }

      // Speaking detection for local mic
      function startLocalSpeakingDetection() {
        if (!window._roomLocalStream) return;
        try {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioCtx.createMediaStreamSource(window._roomLocalStream);
          localAnalyser = audioCtx.createAnalyser();
          localAnalyser.fftSize = 256;
          source.connect(localAnalyser);
          const dataArray = new Uint8Array(localAnalyser.frequencyBinCount);
          speakingPollInterval = setInterval(() => {
            if (!localAnalyser) return;
            localAnalyser.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
            const speaking = avg > 20;
            const el = document.querySelector(`.vr-participant[data-participant-key="${myKey}"]`);
            if (el) el.classList.toggle('speaking', speaking);
          }, 100);
        } catch (e) { console.warn('Speaking detection failed:', e); }
      }

      // Speaking detection for remote streams
      function startRemoteSpeakingDetection(peerKey, stream) {
        if (remoteAnalysers[peerKey]) return;
        try {
          if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
          const source = audioCtx.createMediaStreamSource(stream);
          const analyser = audioCtx.createAnalyser();
          analyser.fftSize = 256;
          source.connect(analyser);
          const dataArray = new Uint8Array(analyser.frequencyBinCount);
          const interval = setInterval(() => {
            analyser.getByteFrequencyData(dataArray);
            const avg = dataArray.reduce((a, b) => a + b, 0) / dataArray.length;
            const speaking = avg > 20;
            const el = document.querySelector(`.vr-participant[data-participant-key="${peerKey}"]`);
            if (el) el.classList.toggle('speaking', speaking);
          }, 100);
          remoteAnalysers[peerKey] = { analyser, source, interval };
        } catch (e) { console.warn('Remote speaking detection failed:', e); }
      }

      function stopSpeakingDetection() {
        if (speakingPollInterval) { clearInterval(speakingPollInterval); speakingPollInterval = null; }
        localAnalyser = null;
        for (const [key, r] of Object.entries(remoteAnalysers)) {
          clearInterval(r.interval);
        }
        remoteAnalysers = {};
        if (audioCtx) { audioCtx.close().catch(() => {}); audioCtx = null; }
        // Remove speaking classes
        document.querySelectorAll('.vr-participant.speaking').forEach(el => el.classList.remove('speaking'));
      }

      // Patch setupRoomAudio to start speaking detection + update bar
      const _origSetupRoomAudio = setupRoomAudio;
      window.setupRoomAudio = async function() {
        await _origSetupRoomAudio();
        if (window._roomLocalStream) {
          startLocalSpeakingDetection();
          updateVoiceControlBar();
          // Reset mute state
          vcMuted = false;
          const btn = document.getElementById('vc-mute-btn');
          if (btn) { btn.textContent = '🎤'; btn.classList.remove('vc-muted'); }
        }
      };

      // Patch cleanupRoomAudio to hide bar
      const _origCleanupRoomAudio = cleanupRoomAudio;
      window.cleanupRoomAudio = function() {
        stopSpeakingDetection();
        _origCleanupRoomAudio();
        updateVoiceControlBar();
      };

      // Patch connectToRoomPeer to add remote speaking detection + volume
      const _origConnectToRoomPeer = connectToRoomPeer;
      window.connectToRoomPeer = async function(peerKey, peerName, roomId, isCaller) {
        await _origConnectToRoomPeer(peerKey, peerName, roomId, isCaller);
        const pc = window._roomPeerConnections[peerKey];
        if (pc) {
          const origOnTrack = pc.ontrack;
          pc.ontrack = function(event) {
            if (origOnTrack) origOnTrack.call(this, event);
            // Apply volume to new audio elements
            setTimeout(() => {
              document.querySelectorAll('.room-remote-audio').forEach(el => { el.volume = vcVolume / 100; });
              // Start speaking detection for this remote stream
              if (event.streams[0]) startRemoteSpeakingDetection(peerKey, event.streams[0]);
            }, 100);
          };
        }
      };

      // Patch renderServerList to update voice control bar
      const _origRenderServerList = window.renderServerList;
      window.renderServerList = function() {
        _origRenderServerList();
        updateVoiceControlBar();
      };

      // ── Channel Settings Cog ──
      let activeCogDropdown = null;

      document.addEventListener('click', function(e) {
        // Close any open cog dropdown
        if (activeCogDropdown && !e.target.closest('.cog-dropdown') && !e.target.closest('.channel-cog')) {
          activeCogDropdown.remove();
          activeCogDropdown = null;
        }

        const cog = e.target.closest('.channel-cog');
        if (!cog) return;
        e.stopPropagation();
        e.preventDefault();

        // Close existing
        if (activeCogDropdown) { activeCogDropdown.remove(); activeCogDropdown = null; }

        const type = cog.dataset.cogType;
        const id = cog.dataset.cogId;
        const name = cog.dataset.cogName;

        const dropdown = document.createElement('div');
        dropdown.className = 'cog-dropdown';

        if (type === 'text') {
          dropdown.innerHTML = `
            <div class="cog-item" data-cog-action="rename">✏️ Rename</div>
            <div class="cog-item danger" data-cog-action="delete">🗑️ Delete</div>
          `;
          dropdown.addEventListener('click', function(ev) {
            const item = ev.target.closest('.cog-item');
            if (!item) return;
            const action = item.dataset.cogAction;
            if (action === 'rename') {
              const newName = prompt('New channel name:', name);
              if (newName && newName.trim() && newName.trim() !== name && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: 'chat', content: '/channel-edit ' + name + ' name ' + newName.trim(), timestamp: Date.now(), channel: activeChannel || 'general' }));
              }
            } else if (action === 'delete') {
              if (confirm('Delete channel "' + name + '"? This cannot be undone.')) {
                if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({ type: 'chat', content: '/channel-delete ' + name, timestamp: Date.now(), channel: activeChannel || 'general' }));
                }
              }
            }
            dropdown.remove();
            activeCogDropdown = null;
          });
        } else if (type === 'voice') {
          dropdown.innerHTML = `
            <div class="cog-item" data-cog-action="rename" style="opacity:0.5;cursor:default;" title="Not yet implemented">✏️ Rename (coming soon)</div>
            <div class="cog-item danger" data-cog-action="delete">🗑️ Delete</div>
          `;
          dropdown.addEventListener('click', function(ev) {
            const item = ev.target.closest('.cog-item');
            if (!item) return;
            const action = item.dataset.cogAction;
            if (action === 'delete') {
              if (confirm('Delete voice channel "' + name + '"?')) {
                if (ws && ws.readyState === WebSocket.OPEN) {
                  ws.send(JSON.stringify({ type: 'voice_room', action: 'delete', room_id: String(id) }));
                }
              }
            }
            dropdown.remove();
            activeCogDropdown = null;
          });
        }

        cog.style.position = 'relative';
        cog.appendChild(dropdown);
        activeCogDropdown = dropdown;
      });
    })();

    // ── Follow/Friend System (Client State) ──
    let myFollowing = new Set(); // keys I'm following
    let myFollowers = new Set(); // keys following me
    let activeGroupId = null; // Currently viewing group
    let activeGroupName = '';
    let myGroups = []; // Array of { id, name, invite_code, role }

    function isFriend(key) {
      return myFollowing.has(key) && myFollowers.has(key);
    }

    function isFollowing(key) {
      return myFollowing.has(key);
    }

    function resolveNameToKey(name) {
      // Search through the known user list for a matching name
      const lowerName = name.toLowerCase();
      const peerList = document.getElementById('peer-list');
      if (!peerList) return null;
      const peers = peerList.querySelectorAll('.peer[data-pubkey]');
      for (const el of peers) {
        const peerName = (el.dataset.username || '').toLowerCase();
        if (peerName === lowerName) return el.dataset.pubkey;
      }
      return null;
    }

    // Handle follow/friend/group messages from server
    const _origHandleMessageFollow = handleMessage;
    handleMessage = function(msg) {
      if (msg.type === 'follow_list') {
        myFollowing = new Set(msg.following || []);
        myFollowers = new Set(msg.followers || []);
        updateFriendIndicators();
        return;
      }
      if (msg.type === 'follow_update') {
        if (msg.follower_key === myKey) {
          if (msg.action === 'follow') myFollowing.add(msg.followed_key);
          else myFollowing.delete(msg.followed_key);
        }
        if (msg.followed_key === myKey) {
          if (msg.action === 'follow') myFollowers.add(msg.follower_key);
          else myFollowers.delete(msg.follower_key);
        }
        updateFriendIndicators();
        return;
      }
      if (msg.type === 'group_list') {
        myGroups = msg.groups || [];
        renderGroupList();
        return;
      }
      if (msg.type === 'group_message') {
        if (activeGroupId === msg.group_id) {
          const name = msg.from_name || shortKey(msg.from);
          const isYou = msg.from === myKey;
          addMessageToChat(name, msg.content, msg.timestamp, isYou, msg.from);
        }
        return;
      }
      if (msg.type === 'group_history') {
        if (msg.group_id === activeGroupId) {
          const messagesDiv = document.getElementById('messages');
          messagesDiv.innerHTML = '';
          for (const m of (msg.messages || [])) {
            const isYou = m.from === myKey;
            addMessageToChat(m.from_name || shortKey(m.from), m.content, m.timestamp, isYou, m.from);
          }
        }
        return;
      }
      _origHandleMessageFollow(msg);
    };

    function updateFriendIndicators() {
      // Update friend/follow icons next to peers in the peer list
      document.querySelectorAll('.peer[data-pubkey]').forEach(el => {
        const key = el.dataset.pubkey;
        if (!key || key === myKey) return;
        // Remove old indicators
        el.querySelectorAll('.follow-indicator').forEach(x => x.remove());
        if (isFriend(key)) {
          const badge = document.createElement('span');
          badge.className = 'follow-indicator';
          badge.textContent = ' 🤝';
          badge.title = 'Friend (mutual follow)';
          el.querySelector('.peer-name')?.appendChild(badge) || el.appendChild(badge);
        } else if (isFollowing(key)) {
          const badge = document.createElement('span');
          badge.className = 'follow-indicator';
          badge.textContent = ' 👁️';
          badge.title = 'Following';
          el.querySelector('.peer-name')?.appendChild(badge) || el.appendChild(badge);
        } else if (myFollowers.has(key)) {
          const badge = document.createElement('span');
          badge.className = 'follow-indicator';
          badge.textContent = ' 👁️‍🗨️';
          badge.title = 'Follows you';
          el.querySelector('.peer-name')?.appendChild(badge) || el.appendChild(badge);
        }
      });
    }

    // Patch updateUserList to add friend indicators after render
    const _origUpdateUserListFollow = updateUserList;
    updateUserList = function(users) {
      _origUpdateUserListFollow(users);
      updateFriendIndicators();
      addFollowContextMenu();
    };

    function addFollowContextMenu() {
      document.querySelectorAll('.peer[data-pubkey]').forEach(el => {
        const key = el.dataset.pubkey;
        if (!key || key === myKey) return;
        el.removeEventListener('contextmenu', el._followCtx);
        el._followCtx = function(e) {
          e.preventDefault();
          // Remove any existing context menu
          document.querySelectorAll('.follow-ctx-menu').forEach(m => m.remove());
          const menu = document.createElement('div');
          menu.className = 'follow-ctx-menu';
          menu.style.cssText = 'position:fixed;z-index:9999;background:var(--bg-secondary);border:1px solid var(--border);border-radius:8px;padding:4px 0;min-width:140px;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
          menu.style.left = e.clientX + 'px';
          menu.style.top = e.clientY + 'px';

          const following = myFollowing.has(key);
          const item = document.createElement('div');
          item.style.cssText = 'padding:6px 12px;cursor:pointer;font-size:0.82rem;color:var(--text);';
          item.textContent = following ? '❌ Unfollow' : '👁️ Follow';
          item.onmouseenter = () => { item.style.background = 'var(--bg-hover)'; };
          item.onmouseleave = () => { item.style.background = ''; };
          item.onclick = () => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: following ? 'unfollow' : 'follow', target_key: key }));
            }
            menu.remove();
          };
          menu.appendChild(item);

          document.body.appendChild(menu);
          const closeMenu = (ev) => { if (!menu.contains(ev.target)) { menu.remove(); document.removeEventListener('click', closeMenu); } };
          setTimeout(() => document.addEventListener('click', closeMenu), 0);
        };
        el.addEventListener('contextmenu', el._followCtx);
      });
    }

    function renderGroupList() {
      const container = document.getElementById('tab-groups');
      if (!container) return;
      if (myGroups.length === 0) {
        container.innerHTML = '<div style="padding:0.5rem;color:var(--text-muted);font-size:0.8rem;">No groups yet.<br>Use <code>/group-create &lt;name&gt;</code> to create one.</div>';
        return;
      }
      let html = '';
      for (const g of myGroups) {
        const isActive = activeGroupId === g.id;
        html += `<div class="channel-item${isActive ? ' active' : ''}" data-group-id="${g.id}" style="cursor:pointer;">
          <span style="opacity:0.6">👥 </span>${esc(g.name)}
          <span style="font-size:0.6rem;color:var(--text-muted);margin-left:auto;">${g.role}</span>
        </div>`;
      }
      html += '<div style="padding:0.3rem 0;"><button class="vr-btn" onclick="promptCreateGroup()" style="width:100%;font-size:0.7rem;">+ Create Group</button></div>';
      container.innerHTML = html;
      // Click handler for groups
      container.querySelectorAll('[data-group-id]').forEach(el => {
        el.onclick = () => openGroup(el.dataset.groupId);
        el.oncontextmenu = (e) => {
          e.preventDefault();
          document.querySelectorAll('.group-ctx-menu').forEach(m => m.remove());
          const gid = el.dataset.groupId;
          const group = myGroups.find(g => g.id === gid);
          if (!group) return;
          const menu = document.createElement('div');
          menu.className = 'group-ctx-menu';
          menu.style.cssText = 'position:fixed;z-index:9999;background:var(--bg-secondary);border:1px solid var(--border);border-radius:8px;padding:4px 0;min-width:150px;box-shadow:0 4px 12px rgba(0,0,0,0.3);';
          menu.style.left = e.clientX + 'px';
          menu.style.top = e.clientY + 'px';
          const items = [
            { label: '📋 Copy Invite Code', action: () => { navigator.clipboard.writeText(group.invite_code).then(() => addSystemMessage('Invite code copied: ' + group.invite_code)); }},
            { label: '👤 Invite User', action: () => { const name = prompt('Share this invite code with a user:\\n' + group.invite_code + '\\n\\nOr enter a username to tell them:'); if (name && name.trim()) { addSystemMessage('Share this invite code with ' + name.trim() + ': ' + group.invite_code); } }},
            { label: '🚪 Leave Group', action: () => { if (confirm('Leave group "' + group.name + '"?') && ws && ws.readyState === WebSocket.OPEN) { ws.send(JSON.stringify({ type: 'group_leave', group_id: gid })); if (activeGroupId === gid) { activeGroupId = null; activeGroupName = ''; } } }},
          ];
          items.forEach(it => {
            const div = document.createElement('div');
            div.style.cssText = 'padding:6px 12px;cursor:pointer;font-size:0.82rem;color:var(--text);';
            div.textContent = it.label;
            div.onmouseenter = () => { div.style.background = 'var(--bg-hover)'; };
            div.onmouseleave = () => { div.style.background = ''; };
            div.onclick = (ev) => { ev.stopPropagation(); menu.remove(); it.action(); };
            menu.appendChild(div);
          });
          document.body.appendChild(menu);
          const closeMenu = (ev) => { if (!menu.contains(ev.target)) { menu.remove(); document.removeEventListener('click', closeMenu); } };
          setTimeout(() => document.addEventListener('click', closeMenu), 0);
        };
      });
    }

    function promptCreateGroup() {
      const name = prompt('Group name:');
      if (name && name.trim() && ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: 'group_create', name: name.trim() }));
      }
    }

    function openGroup(groupId) {
      const group = myGroups.find(g => g.id === groupId);
      if (!group) return;
      activeGroupId = groupId;
      activeGroupName = group.name;
      activeDmPartner = null; // Exit DM view
      // Update channel header
      const header = document.getElementById('channel-header');
      if (header) {
        header.style.display = 'flex';
        header.querySelector('.ch-name').textContent = '👥 ' + group.name;
        header.querySelector('.ch-desc').textContent = 'Group • Invite: ' + group.invite_code;
      }
      // Clear messages and load group history (if server supports it)
      document.getElementById('messages').innerHTML = '<div style="text-align:center;color:var(--text-muted);padding:1rem;font-size:0.8rem;">Group: ' + esc(group.name) + '<br>Invite code: <code>' + group.invite_code + '</code></div>';
      renderGroupList();
    }

    // When switching to a channel, clear group view
    const _origSwitchChannelFollow = switchChannel;
    switchChannel = function(channelId) {
      activeGroupId = null;
      activeGroupName = '';
      _origSwitchChannelFollow(channelId);
    };

    // Helper to add a message to the chat (for groups)
    function addMessageToChat(name, content, timestamp, isYou, fromKey) {
      const messagesDiv = document.getElementById('messages');
      const div = document.createElement('div');
      div.className = 'message';
      const time = new Date(timestamp);
      const timeStr = time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      div.innerHTML = `<div class="meta"><span class="author${isYou ? ' you' : ''}">${esc(name)}</span><span class="timestamp">${timeStr}</span></div><div class="body">${esc(content)}</div>`;
      messagesDiv.appendChild(div);
      messagesDiv.scrollTop = messagesDiv.scrollHeight;
    }

    // ── Voice Call / WebRTC (1-on-1 DM calls) ──
    let callState = 'idle'; // idle | ringing-out | ringing-in | in-call
    let callPeerKey = null;
    let callPeerName = '';
    let peerConnection = null;
    let pendingIceCandidates = []; // Buffer ICE candidates arriving before PC is ready
    let remoteDescriptionSet = false; // Track whether remote description has been set
    let localStream = null;
    let callTimerInterval = null;
    let callStartTime = null;
    let isMuted = false;

    function startCall(targetKey, targetName) {
      if (callState !== 'idle') {
        addSystemMessage('You are already in a call or ringing.');
        return;
      }
      if (!ws || ws.readyState !== WebSocket.OPEN) return;

      callState = 'ringing-out';
      callPeerKey = targetKey;
      callPeerName = targetName;

      ws.send(JSON.stringify({
        type: 'voice_call',
        from: myKey,
        to: targetKey,
        action: 'ring'
      }));

      // Show ringing status
      document.getElementById('ringing-status').textContent = `📞 Calling ${esc(targetName)}…`;
      document.getElementById('ringing-status').classList.add('active');

      // Auto-cancel after 30s
      setTimeout(() => {
        if (callState === 'ringing-out') {
          hangupCall();
          addSystemMessage(`${targetName} didn't answer.`);
        }
      }, 30000);
    }

    function acceptIncomingCall() {
      if (callState !== 'ringing-in') return;
      callState = 'in-call';
      document.getElementById('incoming-call-overlay').classList.remove('open');

      ws.send(JSON.stringify({
        type: 'voice_call',
        from: myKey,
        to: callPeerKey,
        action: 'accept'
      }));

      // Callee waits for the offer from caller
      showCallBar();
    }

    function rejectIncomingCall() {
      if (callState !== 'ringing-in') return;
      document.getElementById('incoming-call-overlay').classList.remove('open');

      ws.send(JSON.stringify({
        type: 'voice_call',
        from: myKey,
        to: callPeerKey,
        action: 'reject'
      }));

      resetCallState();
    }

    function hangupCall() {
      if (callState === 'idle') return;

      if (ws && ws.readyState === WebSocket.OPEN && callPeerKey) {
        ws.send(JSON.stringify({
          type: 'voice_call',
          from: myKey,
          to: callPeerKey,
          action: 'hangup'
        }));
      }

      cleanupCall();
    }

    function cleanupCall() {
      if (peerConnection) {
        peerConnection.close();
        peerConnection = null;
      }
      if (localStream) {
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      pendingIceCandidates = [];
      remoteDescriptionSet = false;
      resetCallState();
    }

    function resetCallState() {
      callState = 'idle';
      callPeerKey = null;
      callPeerName = '';
      isMuted = false;
      if (callTimerInterval) { clearInterval(callTimerInterval); callTimerInterval = null; }
      callStartTime = null;
      document.getElementById('call-bar').classList.remove('active');
      document.getElementById('ringing-status').classList.remove('active');
      document.getElementById('incoming-call-overlay').classList.remove('open');
      const muteBtn = document.getElementById('mute-btn');
      muteBtn.classList.remove('muted');
      muteBtn.textContent = '🎤 Mute';
    }

    function showCallBar() {
      document.getElementById('call-peer-name').textContent = `In call with ${callPeerName}`;
      document.getElementById('call-bar').classList.add('active');
      document.getElementById('ringing-status').classList.remove('active');
      callStartTime = Date.now();
      callTimerInterval = setInterval(updateCallTimer, 1000);
    }

    function updateCallTimer() {
      if (!callStartTime) return;
      const elapsed = Math.floor((Date.now() - callStartTime) / 1000);
      const m = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const s = (elapsed % 60).toString().padStart(2, '0');
      document.getElementById('call-timer').textContent = `${m}:${s}`;
    }

    function toggleMute() {
      if (!localStream) return;
      isMuted = !isMuted;
      localStream.getAudioTracks().forEach(t => { t.enabled = !isMuted; });
      const btn = document.getElementById('mute-btn');
      btn.classList.toggle('muted', isMuted);
      btn.textContent = isMuted ? '🔇 Unmute' : '🎤 Mute';
    }

    async function setupPeerConnection(isCaller) {
      peerConnection = new RTCPeerConnection(rtcConfig);

      // Get microphone
      try {
        localStream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: true, noiseSuppression: true, autoGainControl: true }, video: false });
      } catch (e) {
        addSystemMessage('⚠️ Microphone access denied. Cannot make voice call.');
        hangupCall();
        return false;
      }

      localStream.getTracks().forEach(t => peerConnection.addTrack(t, localStream));

      // Play remote audio
      peerConnection.ontrack = (event) => {
        const audio = new Audio();
        audio.srcObject = event.streams[0];
        audio.autoplay = true;
        audio.playsInline = true;
        audio.id = 'remote-audio';
        // Remove old one if any
        const old = document.getElementById('remote-audio');
        if (old) old.remove();
        document.body.appendChild(audio);
        const pp = audio.play();
        if (pp) pp.catch(() => {
          addSystemMessage('⚠️ Tap anywhere to hear incoming audio.');
          const resume = () => { audio.play().catch(()=>{}); document.removeEventListener('click', resume); document.removeEventListener('touchstart', resume); };
          document.addEventListener('click', resume, { once: true });
          document.addEventListener('touchstart', resume, { once: true });
        });
      };

      // ICE candidates → send to peer
      peerConnection.onicecandidate = (event) => {
        if (event.candidate && ws && ws.readyState === WebSocket.OPEN) {
          ws.send(JSON.stringify({
            type: 'webrtc_signal',
            from: myKey,
            to: callPeerKey,
            signal_type: 'ice',
            data: event.candidate.toJSON()
          }));
        }
      };

      peerConnection.onconnectionstatechange = () => {
        if (peerConnection && (peerConnection.connectionState === 'disconnected' || peerConnection.connectionState === 'failed')) {
          addSystemMessage('Call disconnected.');
          cleanupCall();
        }
      };

      return true;
    }

    async function createAndSendOffer() {
      if (!await setupPeerConnection(true)) return;
      const offer = await peerConnection.createOffer();
      await peerConnection.setLocalDescription(offer);
      ws.send(JSON.stringify({
        type: 'webrtc_signal',
        from: myKey,
        to: callPeerKey,
        signal_type: 'offer',
        data: offer
      }));
      showCallBar();
    }

    async function handleOffer(data) {
      if (!await setupPeerConnection(false)) return;
      await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
      remoteDescriptionSet = true;
      await flushPendingIceCandidates();
      const answer = await peerConnection.createAnswer();
      await peerConnection.setLocalDescription(answer);
      ws.send(JSON.stringify({
        type: 'webrtc_signal',
        from: myKey,
        to: callPeerKey,
        signal_type: 'answer',
        data: answer
      }));
    }

    async function handleAnswer(data) {
      if (peerConnection) {
        await peerConnection.setRemoteDescription(new RTCSessionDescription(data));
        remoteDescriptionSet = true;
        await flushPendingIceCandidates();
      }
    }

    async function handleIceCandidate(data) {
      if (peerConnection && remoteDescriptionSet) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data));
        } catch (e) {
          console.warn('ICE candidate error:', e);
        }
      } else {
        // Buffer candidates until PC + remote description are ready
        pendingIceCandidates.push(data);
      }
    }

    async function flushPendingIceCandidates() {
      if (!peerConnection) return;
      const candidates = pendingIceCandidates.splice(0);
      for (const data of candidates) {
        try {
          await peerConnection.addIceCandidate(new RTCIceCandidate(data));
        } catch (e) {
          console.warn('ICE candidate error (buffered):', e);
        }
      }
    }

    // Handle voice_call and webrtc_signal messages
    const _origHandleMessage3 = handleMessage;
    handleMessage = function(msg) {
      if (msg.type === 'voice_call') {
        handleVoiceCallMessage(msg);
        return;
      }
      if (msg.type === 'webrtc_signal') {
        handleWebrtcSignalMessage(msg);
        return;
      }
      _origHandleMessage3(msg);
    };

    function handleVoiceCallMessage(msg) {
      const fromName = msg.from_name || shortKey(msg.from);
      switch (msg.action) {
        case 'ring':
          if (callState !== 'idle') {
            // Already busy — auto-reject
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'voice_call', from: myKey, to: msg.from, action: 'reject' }));
            }
            return;
          }
          callState = 'ringing-in';
          callPeerKey = msg.from;
          callPeerName = fromName;
          document.getElementById('incoming-caller-name').textContent = fromName;
          document.getElementById('incoming-call-overlay').classList.add('open');
          playNotificationChime();
          break;
        case 'accept':
          if (callState === 'ringing-out' && msg.from === callPeerKey) {
            callState = 'in-call';
            // Caller creates the offer
            createAndSendOffer();
          }
          break;
        case 'reject':
          if ((callState === 'ringing-out') && msg.from === callPeerKey) {
            addSystemMessage(`${callPeerName} rejected the call.`);
            resetCallState();
          }
          break;
        case 'hangup':
          if (msg.from === callPeerKey) {
            addSystemMessage(`${callPeerName} hung up.`);
            cleanupCall();
          }
          break;
      }
    }

    function handleWebrtcSignalMessage(msg) {
      if (msg.from !== callPeerKey) return; // Ignore signals from unexpected peers
      switch (msg.signal_type) {
        case 'offer':
          handleOffer(msg.data);
          break;
        case 'answer':
          handleAnswer(msg.data);
          break;
        case 'ice':
          handleIceCandidate(msg.data);
          break;
      }
    }

    // Auto-hangup on WebSocket disconnect
    const _origWsOnClose = null; // We'll patch the openSocket function
    const _origOpenSocket = openSocket;
    openSocket = function() {
      _origOpenSocket();
      // Patch onclose to also cleanup call
      const currentWs = ws;
      if (currentWs) {
        const origOnClose = currentWs.onclose;
        currentWs.onclose = function() {
          if (callState !== 'idle') {
            addSystemMessage('Call ended (disconnected).');
            cleanupCall();
          }
          if (origOnClose) origOnClose.apply(this, arguments);
        };
      }
    };

    // Add 📞 call buttons to user list
    const _origUpdateUserList = updateUserList;
    updateUserList = function(users) {
      _origUpdateUserList(users);
      // Add call buttons to online users (not self, not bots)
      const peerList = document.getElementById('peer-list');
      peerList.querySelectorAll('.peer[data-pubkey]').forEach(el => {
        const pk = el.dataset.pubkey;
        const name = el.dataset.username;
        if (pk === myKey || (pk && pk.startsWith('bot_'))) return;
        // Only add to online users
        if (el.style.opacity === '0.5') return; // offline users have opacity 0.5
        // Check if already has call button
        if (el.querySelector('.call-btn')) return;
        const btn = document.createElement('button');
        btn.className = 'call-btn';
        btn.textContent = '📞';
        btn.title = `Call ${name}`;
        btn.onclick = (e) => {
          e.stopPropagation();
          startCall(pk, name);
        };
        el.appendChild(btn);
        if (window.twemoji) twemoji.parse(btn);
      });
    };
  </script>

  <script>
  // ── Phase 2: Video Calls + Screen Share ──

  // --- DM Call Video ---
  let dmVideoStream = null;
  let dmScreenStream = null;
  let dmVideoActive = false;
  let dmScreenActive = false;

  function toggleVideo() {
    if (!peerConnection) return;
    if (dmVideoActive) {
      stopDmVideo();
    } else {
      startDmVideo();
    }
  }

  async function startDmVideo() {
    if (!peerConnection) return;
    try {
      // Stop screen share if active
      if (dmScreenActive) stopDmScreenShare();
      dmVideoStream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
      const videoTrack = dmVideoStream.getVideoTracks()[0];
      const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) {
        await sender.replaceTrack(videoTrack);
      } else {
        peerConnection.addTrack(videoTrack, dmVideoStream);
      }
      dmVideoActive = true;
      document.getElementById('video-btn').classList.add('active');
      document.getElementById('video-btn').textContent = '📹 On';
      showLocalVideo(dmVideoStream, 'dm-self');
    } catch (e) {
      addSystemMessage('⚠️ Camera access denied.');
    }
  }

  function stopDmVideo() {
    if (dmVideoStream) {
      dmVideoStream.getTracks().forEach(t => t.stop());
      dmVideoStream = null;
    }
    // Remove video sender
    if (peerConnection) {
      const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) { try { peerConnection.removeTrack(sender); } catch(e){} }
    }
    dmVideoActive = false;
    document.getElementById('video-btn').classList.remove('active');
    document.getElementById('video-btn').textContent = '📹 Video';
    removeVideoElement('dm-self');
    updateVideoPanel();
  }

  async function toggleScreenShare() {
    if (!peerConnection) return;
    if (dmScreenActive) {
      stopDmScreenShare();
    } else {
      startDmScreenShare();
    }
  }

  async function startDmScreenShare() {
    if (!peerConnection) return;
    try {
      if (dmVideoActive) stopDmVideo();
      dmScreenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
      const videoTrack = dmScreenStream.getVideoTracks()[0];
      videoTrack.addEventListener('ended', () => { stopDmScreenShare(); });
      const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) {
        await sender.replaceTrack(videoTrack);
      } else {
        peerConnection.addTrack(videoTrack, dmScreenStream);
      }
      dmScreenActive = true;
      document.getElementById('screen-btn').classList.add('active');
      document.getElementById('screen-btn').textContent = '🖥️ On';
      showLocalVideo(dmScreenStream, 'dm-screen');
    } catch (e) {
      // User cancelled the screen share picker
    }
  }

  function stopDmScreenShare() {
    if (dmScreenStream) {
      dmScreenStream.getTracks().forEach(t => t.stop());
      dmScreenStream = null;
    }
    if (peerConnection) {
      const sender = peerConnection.getSenders().find(s => s.track && s.track.kind === 'video');
      if (sender) { try { peerConnection.removeTrack(sender); } catch(e){} }
    }
    dmScreenActive = false;
    const btn = document.getElementById('screen-btn');
    if (btn) { btn.classList.remove('active'); btn.textContent = '🖥️ Screen'; }
    removeVideoElement('dm-screen');
    updateVideoPanel();
  }

  // Patch cleanupCall to also clean up video
  const _origCleanupCall = cleanupCall;
  cleanupCall = function() {
    stopDmVideo();
    stopDmScreenShare();
    // Remove all remote video
    document.querySelectorAll('#video-panel .video-wrapper').forEach(el => el.remove());
    updateVideoPanel();
    _origCleanupCall();
  };

  // Patch resetCallState to reset video buttons
  const _origResetCallState = resetCallState;
  resetCallState = function() {
    _origResetCallState();
    const vb = document.getElementById('video-btn');
    if (vb) { vb.classList.remove('active'); vb.textContent = '📹 Video'; }
    const sb = document.getElementById('screen-btn');
    if (sb) { sb.classList.remove('active'); sb.textContent = '🖥️ Screen'; }
  };

  // Patch peerConnection.ontrack to handle video tracks
  const _origSetupPeerConnection = setupPeerConnection;
  setupPeerConnection = async function(isCaller) {
    const result = await _origSetupPeerConnection(isCaller);
    if (!result || !peerConnection) return result;
    const origOnTrack = peerConnection.ontrack;
    peerConnection.ontrack = function(event) {
      if (event.track.kind === 'video') {
        showRemoteVideo(event.streams[0], 'dm-remote-' + event.track.id, callPeerName || 'Peer');
      } else {
        if (origOnTrack) origOnTrack.call(this, event);
      }
    };
    return result;
  };

  // --- Voice Room Video ---
  let vrVideoStream = null;
  let vrScreenStream = null;
  let vrVideoActive = false;
  let vrScreenActive = false;

  window.toggleVoiceRoomVideo = async function() {
    if (!window._currentRoomId) return;
    if (vrVideoActive) {
      stopVrVideo();
    } else {
      await startVrVideo();
    }
  };

  async function startVrVideo() {
    try {
      if (vrScreenActive) stopVrScreenShare();
      vrVideoStream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
      const videoTrack = vrVideoStream.getVideoTracks()[0];
      // Add video track to all peer connections
      for (const [key, pc] of Object.entries(window._roomPeerConnections)) {
        pc.addTrack(videoTrack, vrVideoStream);
      }
      vrVideoActive = true;
      const btn = document.getElementById('vc-video-btn');
      if (btn) { btn.classList.add('vc-muted'); btn.textContent = '📹✓'; }
      showLocalVideo(vrVideoStream, 'vr-self');
    } catch (e) {
      addSystemMessage('⚠️ Camera access denied.');
    }
  }

  function stopVrVideo() {
    if (vrVideoStream) {
      const videoTrack = vrVideoStream.getVideoTracks()[0];
      for (const [key, pc] of Object.entries(window._roomPeerConnections)) {
        const sender = pc.getSenders().find(s => s.track === videoTrack);
        if (sender) { try { pc.removeTrack(sender); } catch(e){} }
      }
      vrVideoStream.getTracks().forEach(t => t.stop());
      vrVideoStream = null;
    }
    vrVideoActive = false;
    const btn = document.getElementById('vc-video-btn');
    if (btn) { btn.classList.remove('vc-muted'); btn.textContent = '📹'; }
    removeVideoElement('vr-self');
    updateVideoPanel();
  }

  window.toggleVoiceRoomScreenShare = async function() {
    if (!window._currentRoomId) return;
    if (vrScreenActive) {
      stopVrScreenShare();
    } else {
      await startVrScreenShare();
    }
  };

  async function startVrScreenShare() {
    try {
      if (vrVideoActive) stopVrVideo();
      vrScreenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
      const videoTrack = vrScreenStream.getVideoTracks()[0];
      videoTrack.addEventListener('ended', () => { stopVrScreenShare(); });
      for (const [key, pc] of Object.entries(window._roomPeerConnections)) {
        pc.addTrack(videoTrack, vrScreenStream);
      }
      vrScreenActive = true;
      const btn = document.getElementById('vc-screen-btn');
      if (btn) { btn.classList.add('vc-muted'); btn.textContent = '🖥️✓'; }
      showLocalVideo(vrScreenStream, 'vr-screen');
    } catch (e) {
      // User cancelled
    }
  }

  function stopVrScreenShare() {
    if (vrScreenStream) {
      const videoTrack = vrScreenStream.getVideoTracks()[0];
      for (const [key, pc] of Object.entries(window._roomPeerConnections)) {
        const sender = pc.getSenders().find(s => s.track === videoTrack);
        if (sender) { try { pc.removeTrack(sender); } catch(e){} }
      }
      vrScreenStream.getTracks().forEach(t => t.stop());
      vrScreenStream = null;
    }
    vrScreenActive = false;
    const btn = document.getElementById('vc-screen-btn');
    if (btn) { btn.classList.remove('vc-muted'); btn.textContent = '🖥️'; }
    removeVideoElement('vr-screen');
    updateVideoPanel();
  }

  // Patch cleanupRoomAudio to stop video too
  const _origCleanupRoomAudio2 = window.cleanupRoomAudio;
  window.cleanupRoomAudio = function() {
    stopVrVideo();
    stopVrScreenShare();
    document.querySelectorAll('#video-panel .video-wrapper:not([data-id^="dm-"])').forEach(el => el.remove());
    updateVideoPanel();
    _origCleanupRoomAudio2();
  };

  // Patch connectToRoomPeer to handle remote video tracks
  const _origConnectToRoomPeer2 = window.connectToRoomPeer;
  window.connectToRoomPeer = async function(peerKey, peerName, roomId, isCaller) {
    await _origConnectToRoomPeer2(peerKey, peerName, roomId, isCaller);
    const pc = window._roomPeerConnections[peerKey];
    if (!pc) return;
    const origOnTrack = pc.ontrack;
    pc.ontrack = function(event) {
      if (event.track.kind === 'video') {
        const label = peerName || shortKey(peerKey);
        showRemoteVideo(event.streams[0], 'vr-remote-' + peerKey, label);
        event.track.addEventListener('ended', () => {
          removeVideoElement('vr-remote-' + peerKey);
          updateVideoPanel();
        });
      } else {
        if (origOnTrack) origOnTrack.call(this, event);
      }
    };
  };

  // --- Video Panel Helpers ---
  function showLocalVideo(stream, id) {
    removeVideoElement(id);
    const panel = document.getElementById('video-panel');
    const wrapper = document.createElement('div');
    wrapper.className = 'video-wrapper self-view';
    wrapper.dataset.id = id;
    const video = document.createElement('video');
    video.srcObject = stream;
    video.autoplay = true;
    video.playsInline = true;
    video.muted = true;
    const label = document.createElement('div');
    label.className = 'video-label';
    label.textContent = 'You';
    wrapper.appendChild(video);
    wrapper.appendChild(label);
    panel.appendChild(wrapper);
    updateVideoPanel();
  }

  function showRemoteVideo(stream, id, name) {
    removeVideoElement(id);
    const panel = document.getElementById('video-panel');
    const wrapper = document.createElement('div');
    wrapper.className = 'video-wrapper';
    wrapper.dataset.id = id;
    const video = document.createElement('video');
    video.srcObject = stream;
    video.autoplay = true;
    video.playsInline = true;
    const label = document.createElement('div');
    label.className = 'video-label';
    label.textContent = name;
    wrapper.appendChild(video);
    wrapper.appendChild(label);
    panel.appendChild(wrapper);
    video.play().catch(() => {});
    updateVideoPanel();
  }

  function removeVideoElement(id) {
    const el = document.querySelector(`#video-panel .video-wrapper[data-id="${id}"]`);
    if (el) el.remove();
  }

  function updateVideoPanel() {
    const panel = document.getElementById('video-panel');
    const hasVideos = panel.querySelectorAll('.video-wrapper').length > 0;
    panel.classList.toggle('active', hasVideos);
  }

  // ── Phase 3: Connection Quality Stats ──
  let qualityStatsInterval = null;

  function startQualityStats() {
    if (qualityStatsInterval) return;
    qualityStatsInterval = setInterval(async () => {
      // Voice room peers
      for (const [peerKey, pc] of Object.entries(window._roomPeerConnections || {})) {
        const indicator = getQualityIndicator(pc);
        const el = document.querySelector(`.vr-participant[data-participant-key="${peerKey}"]`);
        if (el) {
          let badge = el.querySelector('.quality-indicator');
          if (!badge) {
            badge = document.createElement('span');
            badge.className = 'quality-indicator';
            el.appendChild(badge);
          }
          badge.textContent = await indicator;
        }
      }
      // DM call peer
      if (peerConnection && callState === 'in-call') {
        const ind = await getQualityIndicator(peerConnection);
        const nameEl = document.getElementById('call-peer-name');
        if (nameEl) {
          // Strip old indicator
          nameEl.textContent = nameEl.textContent.replace(/ [🟢🟡🔴⚫]$/, '') + ' ' + ind;
        }
      }
    }, 3000);
  }

  function stopQualityStats() {
    if (qualityStatsInterval) { clearInterval(qualityStatsInterval); qualityStatsInterval = null; }
  }

  async function getQualityIndicator(pc) {
    try {
      const stats = await pc.getStats();
      for (const [, report] of stats) {
        if (report.type === 'candidate-pair' && report.state === 'succeeded' && report.currentRoundTripTime != null) {
          const rtt = report.currentRoundTripTime * 1000; // seconds to ms
          if (rtt < 100) return '🟢';
          if (rtt <= 300) return '🟡';
          return '🔴';
        }
      }
      return '⚫';
    } catch (e) {
      return '⚫';
    }
  }

  // Start quality stats when in voice room or call
  const _origShowCallBar = showCallBar;
  showCallBar = function() {
    _origShowCallBar();
    startQualityStats();
  };

  const _origResetCallState2 = resetCallState;
  resetCallState = function() {
    _origResetCallState2();
    if (!window._currentRoomId) stopQualityStats();
  };

  // Start/stop quality stats with voice room
  const _origSetupRoomAudio2 = window.setupRoomAudio;
  window.setupRoomAudio = async function() {
    await _origSetupRoomAudio2();
    startQualityStats();
  };

  const _origCleanupRoomAudio3 = window.cleanupRoomAudio;
  window.cleanupRoomAudio = function() {
    _origCleanupRoomAudio3();
    if (callState === 'idle') stopQualityStats();
  };

  // ── Phase 4: Web Push Notifications (SW-based) ──
  function sendSWNotification(title, body, tag, url) {
    if (!document.hidden) return; // Only notify when tab is backgrounded
    if (!('serviceWorker' in navigator) || !navigator.serviceWorker.controller) return;
    // Request permission if needed
    if (Notification.permission === 'default') {
      Notification.requestPermission();
      return;
    }
    if (Notification.permission !== 'granted') return;
    navigator.serviceWorker.controller.postMessage({
      type: 'notification',
      title: title,
      body: body,
      tag: tag || 'humanity',
      url: url || '/chat'
    });
  }

  // Request notification permission on first interaction
  document.addEventListener('click', function requestNotifPerm() {
    if ('Notification' in window && Notification.permission === 'default') {
      Notification.requestPermission();
    }
    document.removeEventListener('click', requestNotifPerm);
  }, { once: true });

  // Patch handleMessage to send notifications for DMs and calls
  const _origHandleMessage4 = handleMessage;
  handleMessage = function(msg) {
    // Notification for incoming DM
    if (msg.type === 'private' && msg.from !== myKey && document.hidden) {
      const senderName = msg.from_name || shortKey(msg.from);
      sendSWNotification('DM from ' + senderName, msg.content || 'New message', 'dm-' + msg.from, '/chat');
    }
    // Notification for incoming call
    if (msg.type === 'voice_call' && msg.action === 'ring' && document.hidden) {
      const callerName = msg.from_name || shortKey(msg.from);
      sendSWNotification('Incoming call from ' + callerName, 'Tap to answer', 'call-' + msg.from, '/chat');
    }
    _origHandleMessage4(msg);
  };
  </script>

  <script>
  // Global Escape key handler to close modals/dropdowns
  document.addEventListener('keydown', function(e) {
    // Ctrl+F opens search
    if ((e.ctrlKey || e.metaKey) && e.key === 'f') {
      e.preventDefault();
      toggleSearch();
      return;
    }
    if (e.key === 'Escape') {
      // Close search panel
      const searchBar = document.getElementById('search-bar');
      if (searchBar && searchBar.classList.contains('open')) { closeSearch(); return; }
      // Close help modal
      const helpOverlay = document.getElementById('help-modal-overlay');
      if (helpOverlay && helpOverlay.classList.contains('open')) { helpOverlay.classList.remove('open'); return; }
      // Close view profile modal
      const profileOverlay = document.getElementById('view-profile-overlay');
      if (profileOverlay && profileOverlay.classList.contains('open')) { profileOverlay.classList.remove('open'); return; }
      // Close edit profile modal
      const editOverlay = document.getElementById('edit-profile-overlay');
      if (editOverlay && editOverlay.classList.contains('open')) { editOverlay.classList.remove('open'); return; }
      // Close cog dropdown
      if (typeof activeCogDropdown !== 'undefined' && activeCogDropdown) { activeCogDropdown.remove(); activeCogDropdown = null; return; }
      // Close context menus
      document.querySelectorAll('.follow-ctx-menu, .group-ctx-menu').forEach(m => m.remove());
      const ctxMenu = document.getElementById('user-context-menu');
      if (ctxMenu && ctxMenu.classList.contains('open')) { ctxMenu.classList.remove('open'); return; }
    }
  });
  </script>

  <script>
  /* ── Command Palette ── */
  function getCmdPaletteItems() {
    const myRole = (typeof peerData !== 'undefined' && typeof myKey !== 'undefined' && peerData[myKey] && peerData[myKey].role) ? peerData[myKey].role : '';
    const isMod = myRole === 'admin' || myRole === 'mod';
    const isAdmin = myRole === 'admin';

    const cats = [
      { name: '📱 Social', items: [
        { icon: '👁️', label: 'Follow User', desc: '/follow', cmd: '/follow ', prefill: true },
        { icon: '🚫', label: 'Unfollow User', desc: '/unfollow', cmd: '/unfollow ', prefill: true },
        { icon: '🚷', label: 'Block User', desc: '/block', cmd: '/block ', prefill: true },
        { icon: '✅', label: 'Unblock User', desc: '/unblock', cmd: '/unblock ', prefill: true },
        { icon: '📋', label: 'Block List', desc: 'View blocks', cmd: '/blocklist' },
        { icon: '🎟️', label: 'Share Friend Code', desc: 'Generate code', action: function(){ sendFriendCodeRequest(); } },
        { icon: '🔓', label: 'Redeem Friend Code', desc: '/redeem', cmd: '/redeem ', prefill: true },
      ]},
      { name: '💬 Messaging', items: [
        { icon: '📩', label: 'Direct Message', desc: '/dm', cmd: '/dm ', prefill: true },
        { icon: '👥', label: 'Create Group', desc: '/group-create', cmd: '/group-create ', prefill: true },
        { icon: '📨', label: 'Invite to Group', desc: '/group-invite', cmd: '/group-invite ', prefill: true },
        { icon: '🚪', label: 'Leave Group', desc: 'Leave current', cmd: '/group-leave' },
      ]},
      { name: '👤 Profile', items: [
        { icon: '📝', label: 'Set Bio', desc: '/bio', cmd: '/bio ', prefill: true },
        { icon: '🔗', label: 'Set Social Link', desc: '/social', cmd: '/social ', prefill: true },
        { icon: '👀', label: 'View Profile', desc: '/profile', cmd: '/profile ', prefill: true },
      ]},
      { name: '🔍 Search', items: [
        { icon: '🔍', label: 'Search Messages', desc: 'Open search panel', action: () => toggleSearch() },
        { icon: '🔎', label: 'Search Command', desc: '/search query', cmd: '/search ', prefill: true },
      ]},
      { name: '📌 Pins', items: [
        { icon: '📌', label: 'Pin Message', desc: '/pin', cmd: '/pin ', prefill: true },
        { icon: '📌', label: 'Personal Pin', desc: '/mypin', cmd: '/mypin ', prefill: true },
      ]},
    ];

    if (isMod) {
      cats.push({ name: '🛡️ Moderation', items: [
        { icon: '👢', label: 'Kick', desc: '/kick', cmd: '/kick ', prefill: true },
        { icon: '🔨', label: 'Ban', desc: '/ban', cmd: '/ban ', prefill: true },
        { icon: '🔇', label: 'Mute', desc: '/mute', cmd: '/mute ', prefill: true },
        { icon: '📋', label: 'View Reports', desc: 'See reports', cmd: '/reports' },
      ]});
    }

    if (isAdmin) {
      cats.push({ name: '⚙️ Admin', items: [
        { icon: '✅', label: 'Verify User', desc: '/verify', cmd: '/verify ', prefill: true },
        { icon: '🛡️', label: 'Make Mod', desc: '/mod', cmd: '/mod ', prefill: true },
        { icon: '🔒', label: 'Lockdown', desc: 'Toggle lock', cmd: '/lockdown' },
        { icon: '📢', label: 'Create Channel', desc: '/channel-create', cmd: '/channel-create ', prefill: true },
      ]});
    }

    cats.push({ name: '🔧 Utility', items: [
      { icon: '❓', label: 'Help', desc: 'Show help', cmd: '/help' },
      { icon: '🔑', label: 'Export Identity', desc: 'Backup keys', cmd: '/export' },
      { icon: '🔗', label: 'Link Device', desc: 'Multi-device', cmd: '/link' },
      { icon: '📊', label: 'Server Stats', desc: 'View stats', cmd: '/stats', action: function(){ window.open('/info','_blank'); } },
    ]});

    return cats;
  }

  function renderCmdPalette() {
    const el = document.getElementById('cmd-palette');
    const cats = getCmdPaletteItems();
    let html = '';
    cats.forEach(function(cat) {
      html += '<div class="cp-category">' + cat.name + '</div>';
      cat.items.forEach(function(item, i) {
        html += '<div class="cp-item" data-cat="' + cat.name + '" data-idx="' + i + '">' +
          '<span class="cp-icon">' + item.icon + '</span>' +
          '<span class="cp-label">' + item.label + '</span>' +
          '<span class="cp-desc">' + item.desc + '</span></div>';
      });
    });
    el.innerHTML = html;

    el.querySelectorAll('.cp-item').forEach(function(row) {
      row.addEventListener('click', function() {
        const catName = row.dataset.cat;
        const idx = parseInt(row.dataset.idx);
        const cat = cats.find(function(c) { return c.name === catName; });
        if (!cat) return;
        const item = cat.items[idx];
        if (!item) return;
        closeCmdPalette();
        if (item.action) { item.action(); return; }
        const input = document.getElementById('msg-input');
        if (item.prefill) {
          input.value = item.cmd;
          input.focus();
          input.setSelectionRange(item.cmd.length, item.cmd.length);
        } else {
          input.value = item.cmd;
          sendMessage();
        }
      });
    });
  }

  function toggleCmdPalette() {
    const overlay = document.getElementById('cmd-palette-overlay');
    if (overlay.classList.contains('open')) {
      closeCmdPalette();
    } else {
      renderCmdPalette();
      // Position palette above input area
      const btn = document.getElementById('cmd-palette-btn');
      const palette = document.getElementById('cmd-palette');
      const inputArea = document.getElementById('input-area');
      const rect = inputArea.getBoundingClientRect();
      palette.style.bottom = (window.innerHeight - rect.top + 4) + 'px';
      palette.style.left = Math.max(4, rect.left) + 'px';
      overlay.classList.add('open');
    }
  }

  function closeCmdPalette() {
    document.getElementById('cmd-palette-overlay').classList.remove('open');
  }

  // Escape to close command palette
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      const overlay = document.getElementById('cmd-palette-overlay');
      if (overlay && overlay.classList.contains('open')) { closeCmdPalette(); e.stopPropagation(); }
    }
  }, true);
  </script>

  <script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('/sw.js')
      .then(reg => console.log('SW registered:', reg.scope))
      .catch(err => console.error('SW failed:', err));
  }
  </script>

  <script>
  /* ── Message Search ── */
  (function() {
    let searchTimer = null;
    let lastSearchTime = 0;

    window.toggleSearch = function() {
      const bar = document.getElementById('search-bar');
      bar.classList.toggle('open');
      if (bar.classList.contains('open')) {
        document.getElementById('search-input').focus();
      } else {
        closeSearch();
      }
    };

    window.closeSearch = function() {
      const bar = document.getElementById('search-bar');
      bar.classList.remove('open');
      document.getElementById('search-input').value = '';
      document.getElementById('search-from').value = '';
      document.getElementById('search-results').innerHTML = '';
      document.getElementById('search-results').classList.remove('open');
      document.getElementById('search-count').textContent = '';
    };

    function doSearch() {
      const query = document.getElementById('search-input').value.trim();
      const fromUser = document.getElementById('search-from').value.trim();
      if (query.length < 2) {
        document.getElementById('search-results').innerHTML = '';
        document.getElementById('search-results').classList.remove('open');
        document.getElementById('search-count').textContent = '';
        return;
      }
      // Rate limit client-side
      const now = Date.now();
      if (now - lastSearchTime < 2000) return;
      lastSearchTime = now;

      const msg = { type: 'search', query: query };
      if (typeof currentChannel !== 'undefined' && currentChannel) {
        // Don't filter by channel — search all. User can filter from dropdown later.
      }
      if (fromUser) msg.from = fromUser;
      if (typeof ws !== 'undefined' && ws && ws.readyState === 1) {
        ws.send(JSON.stringify(msg));
      }
    }

    document.getElementById('search-input').addEventListener('input', function() {
      clearTimeout(searchTimer);
      searchTimer = setTimeout(doSearch, 300);
    });
    document.getElementById('search-from').addEventListener('input', function() {
      clearTimeout(searchTimer);
      searchTimer = setTimeout(doSearch, 300);
    });
    document.getElementById('search-input').addEventListener('keydown', function(e) {
      if (e.key === 'Escape') closeSearch();
      if (e.key === 'Enter') { clearTimeout(searchTimer); doSearch(); }
    });

    function renderSearchResults(data) {
      const container = document.getElementById('search-results');
      const countEl = document.getElementById('search-count');
      if (!data.results || data.results.length === 0) {
        container.innerHTML = '<div style="padding:12px;color:var(--text-muted);text-align:center;">No results found</div>';
        container.classList.add('open');
        countEl.textContent = '0 results';
        return;
      }
      countEl.textContent = data.total + ' result' + (data.total !== 1 ? 's' : '');
      const query = data.query.toLowerCase();
      container.innerHTML = data.results.map(r => {
        const time = new Date(r.timestamp).toLocaleString();
        // Highlight match in content
        const escaped = r.content.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        const highlighted = escaped.replace(new RegExp('(' + query.replace(/[.*+?^${}()|[\]\\]/g, '\\$&') + ')', 'gi'), '<mark>$1</mark>');
        // Truncate content preview
        const preview = highlighted.length > 300 ? highlighted.substring(0, 300) + '…' : highlighted;
        return '<div class="search-result" data-channel="' + (r.channel || '') + '" data-timestamp="' + r.timestamp + '">' +
          '<div class="sr-meta"><span class="sr-author">' + (r.from_name || 'Unknown') + '</span>' +
          '<span class="sr-channel">#' + (r.channel || '?') + '</span>' +
          '<span class="sr-time">' + time + '</span></div>' +
          '<div class="sr-body">' + preview + '</div></div>';
      }).join('');
      container.classList.add('open');

      // Click handler for results
      container.querySelectorAll('.search-result').forEach(el => {
        el.addEventListener('click', function() {
          const ch = this.dataset.channel;
          const ts = parseInt(this.dataset.timestamp);
          if (ch && ch !== 'DM' && typeof switchChannel === 'function') {
            switchChannel(ch);
          }
          closeSearch();
          // Try to scroll to message near that timestamp
          setTimeout(() => {
            const msgs = document.querySelectorAll('.message');
            let closest = null, closestDiff = Infinity;
            msgs.forEach(m => {
              const mts = parseInt(m.dataset.timestamp || '0');
              const diff = Math.abs(mts - ts);
              if (diff < closestDiff) { closestDiff = diff; closest = m; }
            });
            if (closest) closest.scrollIntoView({ behavior: 'smooth', block: 'center' });
          }, 500);
        });
      });
    }

    // Monkey-patch handleMessage for search_results
    const _origHandleMessageSearch = handleMessage;
    handleMessage = function(msg) {
      if (msg.type === 'search_results') {
        renderSearchResults(msg);
        return;
      }
      _origHandleMessageSearch(msg);
    };

    // Handle /search command from chat input
    const _origSendMessageSearch = typeof sendMessage === 'function' ? sendMessage : null;
    if (_origSendMessageSearch) {
      window._searchSendMessagePatched = true;
    }
  })();

  // ── Friend Code System ──
  window.sendFriendCodeRequest = function() {
    if (typeof ws !== 'undefined' && ws && ws.readyState === 1) {
      ws.send(JSON.stringify({ type: 'friend_code_request' }));
    } else {
      addSystemMessage('Not connected to server.');
    }
  };

  // Monkey-patch handleMessage for friend code messages
  const _origHandleMessageFriendCode = handleMessage;
  handleMessage = function(msg) {
    if (msg.type === 'friend_code_response') {
      showFriendCodeDisplay(msg.code);
      return;
    }
    if (msg.type === 'friend_code_result') {
      if (msg.success) {
        addSystemMessage(msg.message);
      } else {
        addSystemMessage('❌ ' + msg.message);
      }
      return;
    }
    _origHandleMessageFriendCode(msg);
  };

  function showFriendCodeDisplay(code) {
    // Remove existing overlay if any
    const existing = document.getElementById('friend-code-overlay');
    if (existing) existing.remove();

    const expiresAt = Date.now() + 24 * 60 * 60 * 1000;

    const overlay = document.createElement('div');
    overlay.id = 'friend-code-overlay';
    overlay.style.cssText = 'position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);display:flex;align-items:center;justify-content:center;z-index:10000;';
    overlay.onclick = function(e) { if (e.target === overlay) overlay.remove(); };

    const modal = document.createElement('div');
    modal.style.cssText = 'background:var(--bg-secondary,#2b2d31);border-radius:12px;padding:32px;max-width:420px;width:90%;text-align:center;color:var(--text-primary,#fff);box-shadow:0 8px 32px rgba(0,0,0,0.5);';

    const title = document.createElement('h2');
    title.textContent = '🎟️ Your Friend Code';
    title.style.cssText = 'margin:0 0 8px;font-size:1.3rem;';

    const desc = document.createElement('p');
    desc.textContent = 'Share this code with a friend so they can add you!';
    desc.style.cssText = 'margin:0 0 20px;color:var(--text-muted,#999);font-size:0.9rem;';

    const codeEl = document.createElement('div');
    codeEl.textContent = code;
    codeEl.style.cssText = 'font-family:monospace;font-size:2.5rem;font-weight:bold;letter-spacing:0.3em;padding:16px 24px;background:var(--bg-primary,#1e1f22);border-radius:8px;margin:0 0 16px;user-select:all;cursor:pointer;border:2px dashed var(--text-muted,#666);';
    codeEl.title = 'Click to select';

    const copyBtn = document.createElement('button');
    copyBtn.textContent = '📋 Copy Code';
    copyBtn.style.cssText = 'background:var(--accent,#5865f2);color:#fff;border:none;border-radius:6px;padding:10px 24px;font-size:1rem;cursor:pointer;margin:0 8px 16px;';
    copyBtn.onclick = function() {
      navigator.clipboard.writeText(code).then(function() {
        copyBtn.textContent = '✅ Copied!';
        setTimeout(function() { copyBtn.textContent = '📋 Copy Code'; }, 2000);
      });
    };

    const closeBtn = document.createElement('button');
    closeBtn.textContent = 'Close';
    closeBtn.style.cssText = 'background:var(--bg-hover,#404249);color:var(--text-primary,#fff);border:none;border-radius:6px;padding:10px 24px;font-size:1rem;cursor:pointer;margin:0 8px 16px;';
    closeBtn.onclick = function() { overlay.remove(); };

    const timerEl = document.createElement('div');
    timerEl.style.cssText = 'color:var(--text-muted,#999);font-size:0.85rem;margin-top:4px;';

    function updateTimer() {
      const remaining = expiresAt - Date.now();
      if (remaining <= 0) { timerEl.textContent = 'Expired'; return; }
      const hours = Math.floor(remaining / 3600000);
      const mins = Math.floor((remaining % 3600000) / 60000);
      timerEl.textContent = 'Expires in ' + hours + 'h ' + mins + 'm • Single use';
      setTimeout(updateTimer, 60000);
    }
    updateTimer();

    const note = document.createElement('div');
    note.textContent = 'They can redeem it with /redeem ' + code;
    note.style.cssText = 'color:var(--text-muted,#999);font-size:0.8rem;margin-top:12px;';

    modal.appendChild(title);
    modal.appendChild(desc);
    modal.appendChild(codeEl);
    modal.appendChild(copyBtn);
    modal.appendChild(closeBtn);
    modal.appendChild(timerEl);
    modal.appendChild(note);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
  }

  // Intercept /friend-code and /redeem commands in chat input
  const _origSendMsgFriendCode = sendMessage;
  sendMessage = function() {
    const input = document.getElementById('msg-input');
    const val = (input && input.value || '').trim();
    if (val === '/friend-code' || val === '/friendcode') {
      input.value = '';
      sendFriendCodeRequest();
      return;
    }
    if (val.startsWith('/redeem ')) {
      const code = val.substring(8).trim().toUpperCase();
      if (code && ws && ws.readyState === 1) {
        input.value = '';
        ws.send(JSON.stringify({ type: 'friend_code_redeem', code: code }));
      } else if (!code) {
        addSystemMessage('Usage: /redeem <code>');
        input.value = '';
      }
      return;
    }
    return _origSendMsgFriendCode.apply(this, arguments);
  };

  // Patch sendMessage to intercept /search command
  if (!window._searchSendPatched) {
    const _origSendMsg = sendMessage;
    sendMessage = function() {
      const input = document.getElementById('msg-input');
      const val = (input && input.value || '').trim();
      if (val.startsWith('/search ')) {
        const query = val.substring(8).trim();
        if (query.length >= 2) {
          toggleSearch();
          document.getElementById('search-input').value = query;
          // Trigger search
          document.getElementById('search-input').dispatchEvent(new Event('input'));
        }
        input.value = '';
        return;
      }
      return _origSendMsg.apply(this, arguments);
    };
    window._searchSendPatched = true;
  }
  </script>

</body>
</html>
